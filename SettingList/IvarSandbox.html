<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>æ’æ˜Ÿç³»ã€Œå¥¥ã€è¿åŠ¨æ¨¡æ‹Ÿå™¨</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #000;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            overflow: hidden;
            color: white;
        }
        
        #container {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #ui {
            position: absolute;
            top: 10px;
            left: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        
        #controls {
            position: absolute;
            bottom: 10px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            gap: 15px;
            align-items: center;
        }
        
        button {
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 255, 255, 0.3);
            color: white;
            padding: 8px 16px;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.3s;
        }
        
        button:hover {
            background: rgba(255, 255, 255, 0.2);
            transform: translateY(-2px);
        }
        
        input[type="range"] {
            width: 150px;
        }
        
        .status {
            margin: 5px 0;
            font-size: 14px;
        }
        
        .phase {
            font-size: 18px;
            font-weight: bold;
            color: #ffeb3b;
            text-shadow: 0 0 10px rgba(255, 235, 59, 0.5);
        }
        
        .eclipse-warning {
            color: #ff4444;
            font-weight: bold;
            text-shadow: 0 0 10px rgba(255, 68, 68, 0.5);
            animation: pulse 2s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        
        #shadow-info {
            position: absolute;
            top: 10px;
            right: 10px;
            z-index: 100;
            background: rgba(0, 0, 0, 0.7);
            padding: 15px;
            border-radius: 10px;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.1);
            max-width: 300px;
        }
    </style>
</head>
<body>
    <div id="container">
        <div id="ui">
            <div class="phase" id="phase">å…‰å¹´æœŸ</div>
            <div class="status" id="planet-pos">è¡Œæ˜Ÿä½ç½®: 4.99 AU</div>
            <div class="status" id="moon-pos">å«æ˜Ÿä½ç½®: 0Â°</div>
            <div class="status" id="eclipse-status">æ—¥é£ŸçŠ¶æ€: æ— </div>
            <div class="status" id="shadow-size">æœ¬å½±åŠå¾„: 45,320 km</div>
            <div class="status" id="time-elapsed">æ—¶é—´: 0.0 ä¼Šç“¦å°”å¹´</div>
        </div>
        
        <div id="shadow-info">
            <h3>æš—æ½®ç°è±¡è§£æ</h3>
            <div id="shadow-details">
                <p>æœ¬å½±é”¥é•¿åº¦: 42,464,000 km</p>
                <p>å«æ˜Ÿè½¨é“å¤„æœ¬å½±åŠå¾„: éšè¡Œæ˜Ÿè·ç¦»å˜åŒ–</p>
                <p>å…¨é£Ÿæ¡ä»¶: æœ¬å½±åŠå¾„ > å«æ˜ŸåŠå¾„ (7,321 km)</p>
                <p>æœ€é•¿å…¨é£Ÿ: 5.0å°æ—¶ (æš—å¹´æ—¶)</p>
            </div>
        </div>
        
        <div id="controls">
            <button onclick="toggleAnimation()">â¸ï¸ æš‚åœ</button>
            <button onclick="resetAnimation()">ğŸ”„ é‡ç½®</button>
            <label>é€Ÿåº¦: <input type="range" id="speed" min="0.01" max="10" value="1" step="0.01" oninput="updateSpeed()"></label>
            <label>è§†è§’: <input type="range" id="view" min="0" max="360" value="45" oninput="updateView()"></label>
            <button onclick="toggleViewMode()">ğŸŒ å…¨å±€è§†è§’</button>
            <button onclick="toggleOrbitPaths()">ğŸ›¤ï¸ è½¨é“</button>
            <button onclick="zoomIn()">ğŸ” æ”¾å¤§</button>
            <button onclick="zoomOut()">ğŸ” ç¼©å°</button>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        // åœºæ™¯è®¾ç½®
        let scene, camera, renderer, controls;
        let star, planet, moon, shadowCone;
        let starLight, planetLight, ambientLight;
        let planetOrbit, moonOrbit;
        let animationRunning = true;
        let timeScale = 1;
        let showOrbitPaths = true;
        
        // ç³»ç»Ÿå‚æ•° (ç¼©æ”¾æ¯”ä¾‹)
        const SCALE = 1000000; // 1ç™¾ä¸‡å€ç¼©æ”¾
        const TIME_SCALE = 365 * 24; // æ—¶é—´åŠ é€Ÿ
        
        // å¢å¤§å¤©ä½“åŠå¾„ä»¥ä¾¿è§‚å¯Ÿ
        const STAR_RADIUS = Math.max(1099206 / SCALE, 5); // æœ€å°5å•ä½
        const PLANET_RADIUS = Math.max(80000 / SCALE, 2); // æœ€å°2å•ä½
        const MOON_RADIUS = Math.max(7321 / SCALE, 1); // æœ€å°1å•ä½
        const PLANET_ORBIT_A = 3.9 * 149597870.7 / SCALE; // AUè½¬kmå†ç¼©æ”¾
        const PLANET_ORBIT_E = 0.28;
        const MOON_ORBIT_R = 2250000 / SCALE;
        const SHADOW_CONE_LENGTH = 42464000 / SCALE;
        
        // æ—¶é—´å˜é‡
        let currentTime = 0;
        let moonAngle = 0;
        let planetAngle = 0;
        let viewMode = 'global'; // 'global' æˆ– 'planet'
        let cameraDistance = 800;
        
        init();
        animate();
        
        function init() {
            // åˆ›å»ºåœºæ™¯
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000011);
            
            // åˆ›å»ºç›¸æœº
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 20000);
            camera.position.set(0, 200, 800);
            camera.lookAt(0, 0, 0);
            
            // åˆ›å»ºæ¸²æŸ“å™¨
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            document.getElementById('container').appendChild(renderer.domElement);
            
            // åˆ›å»ºæ’æ˜Ÿã€Œå¥¥ã€
            const starGeometry = new THREE.SphereGeometry(STAR_RADIUS, 32, 32);
            const starMaterial = new THREE.MeshBasicMaterial({ 
                color: 0xffffff,
                emissive: 0xffffaa,
                emissiveIntensity: 1.0
            });
            star = new THREE.Mesh(starGeometry, starMaterial);
            // æ·»åŠ æ’æ˜Ÿå…‰ç¯æ•ˆæœ
            const starGlow = new THREE.Mesh(
                new THREE.SphereGeometry(STAR_RADIUS * 1.5, 32, 32),
                new THREE.MeshBasicMaterial({ 
                    color: 0xffffaa,
                    transparent: true,
                    opacity: 0.3
                })
            );
            star.add(starGlow);
            scene.add(star);
            
            // åˆ›å»ºè¡Œæ˜Ÿã€Œå¤ªé˜³ã€
            const planetGeometry = new THREE.SphereGeometry(PLANET_RADIUS, 32, 32);
            const planetMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x8866ff,
                specular: 0x4444ff,
                shininess: 100,
                emissive: 0x1122cc,
                emissiveIntensity: 0.2
            });
            planet = new THREE.Mesh(planetGeometry, planetMaterial);
            planet.castShadow = true;
            planet.receiveShadow = true;
            // æ·»åŠ è¡Œæ˜Ÿå…‰ç¯
            const planetGlow = new THREE.Mesh(
                new THREE.SphereGeometry(PLANET_RADIUS * 1.3, 32, 32),
                new THREE.MeshBasicMaterial({ 
                    color: 0x6644ff,
                    transparent: true,
                    opacity: 0.2
                })
            );
            planet.add(planetGlow);
            scene.add(planet);
            
            // åˆ›å»ºå«æ˜Ÿã€Œä¼Šç“¦å°”ã€
            const moonGeometry = new THREE.SphereGeometry(MOON_RADIUS, 16, 16);
            const moonMaterial = new THREE.MeshPhongMaterial({ 
                color: 0x888888,
                specular: 0x222222,
                shininess: 50,
                map: createMoonTexture()
            });
            moon = new THREE.Mesh(moonGeometry, moonMaterial);
            moon.castShadow = true;
            moon.receiveShadow = true;
            scene.add(moon);
            
            // åˆ›å»ºé˜´å½±é”¥ä½“ï¼ˆå¯è§†åŒ–ï¼‰
            const shadowGeometry = new THREE.ConeGeometry(PLANET_RADIUS * 2, SHADOW_CONE_LENGTH, 8);
            const shadowMaterial = new THREE.MeshBasicMaterial({ 
                color: 0x000000,
                transparent: true,
                opacity: 0.3,
                side: THREE.DoubleSide
            });
            shadowCone = new THREE.Mesh(shadowGeometry, shadowMaterial);
            shadowCone.visible = false;
            scene.add(shadowCone);
            
            // åˆ›å»ºè½¨é“è·¯å¾„
            createOrbitPaths();
            
            // åˆ›å»ºå…‰æº
            starLight = new THREE.DirectionalLight(0xffffff, 1);
            starLight.castShadow = true;
            starLight.shadow.mapSize.width = 2048;
            starLight.shadow.mapSize.height = 2048;
            starLight.shadow.camera.near = 0.1;
            starLight.shadow.camera.far = 5000;
            starLight.shadow.camera.left = -1000;
            starLight.shadow.camera.right = 1000;
            starLight.shadow.camera.top = 1000;
            starLight.shadow.camera.bottom = -1000;
            scene.add(starLight);
            
            planetLight = new THREE.PointLight(0x6666ff, 0.5, 2000);
            scene.add(planetLight);
            
            ambientLight = new THREE.AmbientLight(0x404040, 0.1);
            scene.add(ambientLight);
            
            // æ·»åŠ æ˜Ÿç©ºèƒŒæ™¯
            addStarField();
            
            // çª—å£å¤§å°è°ƒæ•´
            window.addEventListener('resize', onWindowResize);
        }
        
        function createOrbitPaths() {
            // è¡Œæ˜Ÿè½¨é“
            const planetOrbitGeometry = new THREE.BufferGeometry();
            const planetOrbitPoints = [];
            for (let i = 0; i <= 360; i++) {
                const angle = (i * Math.PI) / 180;
                const r = PLANET_ORBIT_A * (1 - PLANET_ORBIT_E * PLANET_ORBIT_E) / (1 + PLANET_ORBIT_E * Math.cos(angle));
                const x = r * Math.cos(angle);
                const z = r * Math.sin(angle);
                planetOrbitPoints.push(x, 0, z);
            }
            planetOrbitGeometry.setAttribute('position', new THREE.Float32BufferAttribute(planetOrbitPoints, 3));
            
            const planetOrbitMaterial = new THREE.LineBasicMaterial({ color: 0x666666, transparent: true, opacity: 0.5 });
            planetOrbit = new THREE.Line(planetOrbitGeometry, planetOrbitMaterial);
            scene.add(planetOrbit);
            
            // å«æ˜Ÿè½¨é“ï¼ˆåŠ¨æ€æ›´æ–°ä½ç½®ï¼‰
            const moonOrbitGeometry = new THREE.BufferGeometry();
            const moonOrbitPoints = [];
            for (let i = 0; i <= 360; i++) {
                const angle = (i * Math.PI) / 180;
                const x = MOON_ORBIT_R * Math.cos(angle);
                const z = MOON_ORBIT_R * Math.sin(angle);
                moonOrbitPoints.push(x, 0, z);
            }
            moonOrbitGeometry.setAttribute('position', new THREE.Float32BufferAttribute(moonOrbitPoints, 3));
            
            const moonOrbitMaterial = new THREE.LineBasicMaterial({ color: 0x888888, transparent: true, opacity: 0.3 });
            moonOrbit = new THREE.Line(moonOrbitGeometry, moonOrbitMaterial);
            scene.add(moonOrbit);
        }
        
        function addStarField() {
            const starsGeometry = new THREE.BufferGeometry();
            const starsVertices = [];
            
            for (let i = 0; i < 10000; i++) {
                const x = (Math.random() - 0.5) * 20000;
                const y = (Math.random() - 0.5) * 20000;
                const z = (Math.random() - 0.5) * 20000;
                starsVertices.push(x, y, z);
            }
            
            starsGeometry.setAttribute('position', new THREE.Float32BufferAttribute(starsVertices, 3));
            
            const starsMaterial = new THREE.PointsMaterial({ color: 0xffffff, size: 2 });
            const stars = new THREE.Points(starsGeometry, starsMaterial);
            scene.add(stars);
        }
        
        function animate() {
            requestAnimationFrame(animate);
            
            if (animationRunning) {
                currentTime += 0.01 * timeScale;
                updatePositions();
                updateUI();
            }
            
            renderer.render(scene, camera);
        }
        
        function updatePositions() {
            // æ›´æ–°è¡Œæ˜Ÿä½ç½® (æ¤­åœ†è½¨é“)
            const planetPeriod = 8.4 * 365.25; // åœ°çƒæ—¥
            planetAngle = (currentTime * TIME_SCALE * 2 * Math.PI) / planetPeriod;
            
            // æ¤­åœ†è½¨é“è®¡ç®—
            const r = PLANET_ORBIT_A * (1 - PLANET_ORBIT_E * PLANET_ORBIT_E) / (1 + PLANET_ORBIT_E * Math.cos(planetAngle));
            const planetX = r * Math.cos(planetAngle);
            const planetZ = r * Math.sin(planetAngle);
            
            planet.position.set(planetX, 0, planetZ);
            
            // æ›´æ–°å«æ˜Ÿä½ç½® (ç›¸å¯¹äºè¡Œæ˜Ÿ)
            const moonPeriod = 19.5; // åœ°çƒæ—¥
            moonAngle = (currentTime * TIME_SCALE * 2 * Math.PI) / moonPeriod;
            
            const moonX = planetX + MOON_ORBIT_R * Math.cos(moonAngle);
            const moonZ = planetZ + MOON_ORBIT_R * Math.sin(moonAngle);
            
            moon.position.set(moonX, 0, moonZ);
            
            // æ›´æ–°å«æ˜Ÿè½¨é“ä½ç½®
            moonOrbit.position.set(planetX, 0, planetZ);
            
            // æ›´æ–°å…‰æºä½ç½®
            starLight.position.set(0, 0, 0);
            starLight.target.position.set(planetX, 0, planetZ);
            starLight.target.updateMatrixWorld();
            
            planetLight.position.set(planetX, 0, planetZ);
            
            // æ›´æ–°ç›¸æœºä½ç½®
            updateCamera();
            
            // æ›´æ–°é˜´å½±é”¥
            updateShadowCone(planetX, planetZ, r);
        }
        
        function updateShadowCone(planetX, planetZ, planetDistance) {
            const direction = new THREE.Vector3(planetX, 0, planetZ).normalize();
            const conePosition = new THREE.Vector3().copy(direction).multiplyScalar(planetDistance + SHADOW_CONE_LENGTH / 2);
            
            shadowCone.position.copy(conePosition);
            shadowCone.lookAt(new THREE.Vector3().copy(direction).multiplyScalar(planetDistance + SHADOW_CONE_LENGTH));
            
            // è®¡ç®—æœ¬å½±å¤§å°
            const shadowRadius = calculateShadowRadius(planetDistance);
            shadowCone.scale.set(shadowRadius / PLANET_RADIUS, 1, shadowRadius / PLANET_RADIUS);
        }
        
        function calculateShadowRadius(planetDistance) {
            // ä½¿ç”¨å®é™…çš„å¤©ä½“ç‰©ç†å…¬å¼è®¡ç®—æœ¬å½±åŠå¾„
            // æœ¬å½±åŠå¾„ = è¡Œæ˜ŸåŠå¾„ Ã— (1 - è·ç¦»/æœ¬å½±é”¥é•¿åº¦)
            const realPlanetDistance = planetDistance * SCALE; // å®é™…è·ç¦» km
            const realPlanetRadius = PLANET_RADIUS * SCALE; // å®é™…è¡Œæ˜ŸåŠå¾„ km
            const realMoonOrbitRadius = MOON_ORBIT_R * SCALE; // å®é™…å«æ˜Ÿè½¨é“åŠå¾„ km
            const realShadowConeLength = SHADOW_CONE_LENGTH * SCALE; // å®é™…æœ¬å½±é”¥é•¿åº¦ km
            
            // æœ¬å½±åŠå¾„ = è¡Œæ˜ŸåŠå¾„ Ã— (æœ¬å½±é”¥é•¿åº¦ - å«æ˜Ÿè½¨é“è·ç¦») / æœ¬å½±é”¥é•¿åº¦
            const shadowRadius = realPlanetRadius * (realShadowConeLength - realMoonOrbitRadius) / realShadowConeLength;
            
            return Math.max(0, shadowRadius); // è¿”å›å®é™…åŠå¾„ km
        }
        
        function updateUI() {
            const planetPeriod = 8.4 * 365.25;
            const ivarYear = (currentTime * TIME_SCALE) / 365.25;
            const planetDistance = PLANET_ORBIT_A * (1 - PLANET_ORBIT_E * PLANET_ORBIT_E) / (1 + PLANET_ORBIT_E * Math.cos(planetAngle));
            const realPlanetDistance = planetDistance * SCALE / 149597870.7; // è½¬æ¢ä¸ºAU
            
            // åˆ¤æ–­å…‰å¹´/æš—å¹´
            const isNearPerihelion = realPlanetDistance < 3.5; // è¿‘æ—¥ç‚¹åŒºåŸŸ
            const phase = isNearPerihelion ? "æš—å¹´æœŸ" : "å…‰å¹´æœŸ";
            
            // è®¡ç®—æ—¥é£ŸçŠ¶æ€
            const shadowRadius = calculateShadowRadius(realPlanetDistance * 149597870.7); // ä¼ å…¥km
            const isEclipse = shadowRadius > (MOON_RADIUS * SCALE); // æ¯”è¾ƒå®é™…åŠå¾„
            
            // è®¡ç®—å«æ˜Ÿä¸é˜´å½±é”¥çš„ç›¸å¯¹ä½ç½®
            const moonRelativeAngle = moonAngle * 180 / Math.PI % 360;
            const shadowDirection = Math.atan2(planet.position.z, planet.position.x) * 180 / Math.PI;
            const angleToShadow = Math.abs(moonRelativeAngle - shadowDirection) % 360;
            const inShadow = angleToShadow < 10 || angleToShadow > 350; // 10åº¦å®¹å·®
            
            let eclipseStatus = "æ— ";
            if (isEclipse && inShadow) {
                eclipseStatus = "æš—æ½®å…¨é£Ÿä¸­!";
            } else if (isEclipse) {
                eclipseStatus = "æš—æ½®å¯èƒ½";
            }
            
            // æ›´æ–°UI
            document.getElementById('phase').textContent = phase;
            document.getElementById('phase').className = isNearPerihelion ? 'phase eclipse-warning' : 'phase';
            document.getElementById('planet-pos').textContent = `è¡Œæ˜Ÿä½ç½®: ${realPlanetDistance.toFixed(2)} AU`;
            document.getElementById('moon-pos').textContent = `å«æ˜Ÿä½ç½®: ${moonRelativeAngle.toFixed(1)}Â°`;
            document.getElementById('eclipse-status').textContent = `æ—¥é£ŸçŠ¶æ€: ${eclipseStatus}`;
            document.getElementById('eclipse-status').className = eclipseStatus.includes('æš—æ½®') ? 'status eclipse-warning' : 'status';
            document.getElementById('shadow-size').textContent = `æœ¬å½±åŠå¾„: ${(shadowRadius / 1000).toFixed(0)} km`;
            document.getElementById('time-elapsed').textContent = `æ—¶é—´: ${ivarYear.toFixed(1)} ä¼Šç“¦å°”å¹´`;
            
            // æ˜¾ç¤º/éšè—é˜´å½±é”¥
            shadowCone.visible = isEclipse && showOrbitPaths;
        }
        
        function toggleAnimation() {
            animationRunning = !animationRunning;
            document.querySelector('#controls button').textContent = animationRunning ? 'â¸ï¸ æš‚åœ' : 'â–¶ï¸ æ’­æ”¾';
        }
        
        function resetAnimation() {
            currentTime = 0;
            planetAngle = 0;
            moonAngle = 0;
        }
        
        function updateSpeed() {
            timeScale = parseFloat(document.getElementById('speed').value);
        }
        
        function updateView() {
            const angle = parseInt(document.getElementById('view').value);
            
            if (viewMode === 'global') {
                camera.position.x = cameraDistance * Math.cos(angle * Math.PI / 180);
                camera.position.z = cameraDistance * Math.sin(angle * Math.PI / 180);
                camera.position.y = cameraDistance * 0.3;
                camera.lookAt(0, 0, 0);
            } else if (viewMode === 'planet') {
                // è¡Œæ˜Ÿè§†è§’ä¹Ÿèƒ½è°ƒæ•´è§’åº¦
                const planetPos = planet.position;
                const offset = 50;
                camera.position.set(
                    planetPos.x + offset * Math.cos(angle * Math.PI / 180),
                    planetPos.y + 20,
                    planetPos.z + offset * Math.sin(angle * Math.PI / 180)
                );
                camera.lookAt(planetPos);
            }
        }
        
        function updateCamera() {
            if (viewMode === 'planet') {
                // è¡Œæ˜Ÿè§†è§’ï¼šä½¿ç”¨å½“å‰æ»‘å—è§’åº¦
                const angle = parseInt(document.getElementById('view').value);
                const planetPos = planet.position;
                const offset = 50;
                camera.position.set(
                    planetPos.x + offset * Math.cos(angle * Math.PI / 180),
                    planetPos.y + 20,
                    planetPos.z + offset * Math.sin(angle * Math.PI / 180)
                );
                camera.lookAt(planetPos);
            }
        }
        
        function toggleViewMode() {
            viewMode = viewMode === 'global' ? 'planet' : 'global';
            const button = document.querySelector('button[onclick="toggleViewMode()"]');
            button.textContent = viewMode === 'global' ? 'ğŸŒ å…¨å±€è§†è§’' : 'ğŸª è¡Œæ˜Ÿè§†è§’';
            
            if (viewMode === 'global') {
                updateView();
            }
        }
        
        function zoomIn() {
            cameraDistance *= 0.8;
            if (viewMode === 'global') {
                updateView();
            }
        }
        
        function zoomOut() {
            cameraDistance *= 1.25;
            if (viewMode === 'global') {
                updateView();
            }
        }
        
        function createMoonTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 128;
            canvas.height = 128;
            const ctx = canvas.getContext('2d');
            
            // åˆ›å»ºæœˆçƒè¡¨é¢çº¹ç†
            const gradient = ctx.createRadialGradient(64, 64, 0, 64, 64, 64);
            gradient.addColorStop(0, '#999');
            gradient.addColorStop(1, '#333');
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 128, 128);
            
            // æ·»åŠ é™¨çŸ³å‘
            for (let i = 0; i < 20; i++) {
                const x = Math.random() * 128;
                const y = Math.random() * 128;
                const r = Math.random() * 8 + 2;
                ctx.beginPath();
                ctx.arc(x, y, r, 0, Math.PI * 2);
                ctx.fillStyle = '#222';
                ctx.fill();
            }
            
            const texture = new THREE.CanvasTexture(canvas);
            return texture;
        }
        
        function toggleOrbitPaths() {
            showOrbitPaths = !showOrbitPaths;
            planetOrbit.visible = showOrbitPaths;
            moonOrbit.visible = showOrbitPaths;
            shadowCone.visible = showOrbitPaths && shadowCone.visible;
        }
        
        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }
    </script>
</body>
</html>