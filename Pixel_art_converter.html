<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>像素画转换器v4</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .main-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #e9ecef;
        }

        .control-group h3 {
            color: #495057;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
            margin-bottom: 15px;
        }

        .file-input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-input-button {
            display: block;
            width: 100%;
            padding: 12px;
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            text-align: center;
            border-radius: 8px;
            border: none;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .file-input-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4);
        }

        .slider-group {
            margin-bottom: 12px;
        }

        .slider-group label {
            display: block;
            margin-bottom: 6px;
            color: #495057;
            font-weight: 500;
            font-size: 13px;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .algorithm-selector, .style-selector {
            display: grid;
            gap: 8px;
            margin-bottom: 15px;
        }

        .algorithm-option, .style-option {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
            background: white;
            font-size: 12px;
        }

        .algorithm-option:hover, .style-option:hover {
            border-color: #667eea;
        }

        .algorithm-option.active, .style-option.active {
            border-color: #667eea;
            background: #667eea;
            color: white;
            font-weight: bold;
        }

        .palette-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #e9ecef;
            margin-bottom: 20px;
        }

        .palette-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .palette-btn {
            padding: 8px 16px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .palette-btn:hover {
            background: #5a6fd8;
        }

        .palette-selector {
            margin-bottom: 15px;
        }

        .palette-selector select {
            width: 200px;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 6px;
            margin-right: 10px;
        }

        .palette {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(30px, 1fr));
            gap: 3px;
            margin-bottom: 15px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
        }

        .color-swatch {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .color-swatch:hover {
            transform: scale(1.1);
            border-color: #333;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .color-swatch.selected {
            border-color: #ff0000;
            border-width: 3px;
        }

        .canvas-container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .canvas-wrapper {
            text-align: center;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 15px;
            border: 2px solid #e9ecef;
        }

        .canvas-wrapper h3 {
            margin-bottom: 10px;
            color: #495057;
            font-size: 1em;
        }

        canvas {
            max-width: 100%;
            height: auto;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
        }

        .preview-controls {
            display: flex;
            justify-content: center;
            gap: 5px;
            margin: 10px 0;
        }

        .preview-btn {
            padding: 4px 8px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s ease;
        }

        .preview-btn:hover {
            background: #495057;
        }

        .preview-btn.active {
            background: #667eea;
        }

        .download-section {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .download-btn {
            padding: 10px 20px;
            background: linear-gradient(45deg, #dc3545, #fd7e14);
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-weight: bold;
            text-align: center;
            transition: all 0.3s ease;
            font-size: 12px;
        }

        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(220, 53, 69, 0.4);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }

        .stat-item {
            background: linear-gradient(45deg, #6c757d, #495057);
            color: white;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 3px;
        }

        .loading {
            display: none;
            text-align: center;
            margin: 20px 0;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .color-editor {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            border: 2px solid #ddd;
            display: none;
        }

        .color-editor.active {
            display: block;
        }

        .color-editor input {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .color-editor button {
            padding: 8px 16px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .btn-save {
            background: #28a745;
            color: white;
        }

        .btn-delete {
            background: #dc3545;
            color: white;
        }

        .btn-cancel {
            background: #6c757d;
            color: white;
        }

        @media (max-width: 1400px) {
            .main-controls {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 768px) {
            .main-controls {
                grid-template-columns: 1fr;
            }
            
            .canvas-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>🎨 像素画转换器 v4</h1>
            <p>请输入文字</p>
        </div>

        <div class="main-controls">
            <div class="control-group">
                <h3>📁 图片上传</h3>
                <div class="file-input-wrapper">
                    <input type="file" id="imageInput" class="file-input" accept="image/*">
                    <button class="file-input-button">选择图片文件</button>
                </div>
                <div class="slider-group">
                    <label for="widthSlider">像素画宽度: <span id="widthValue">64</span></label>
                    <input type="range" id="widthSlider" class="slider" min="16" max="256" value="64">
                </div>
            </div>

            <div class="control-group">
                <h3>🎯 转换算法</h3>
                <div class="algorithm-selector">
                    <div class="algorithm-option active" data-algorithm="euclidean">欧几里得距离</div>
                    <div class="algorithm-option" data-algorithm="weighted">加权RGB距离</div>
                    <div class="algorithm-option" data-algorithm="lab">LAB色彩空间</div>
                    <div class="algorithm-option" data-algorithm="dithering">Floyd抖动</div>
                    <div class="algorithm-option" data-algorithm="ordered">有序抖动</div>
                    <div class="algorithm-option" data-algorithm="adaptive">自适应量化</div>
                </div>
            </div>

            <div class="control-group">
                <h3>🎨 艺术风格</h3>
                <div class="style-selector">
                    <div class="style-option active" data-style="sharp">锐利清晰</div>
                    <div class="style-option" data-style="soft">柔和自然</div>
                    <div class="style-option" data-style="retro">复古游戏</div>
                    <div class="style-option" data-style="artistic">艺术化</div>
                    <div class="style-option" data-style="minimal">极简主义</div>
                    <div class="style-option" data-style="vibrant">高饱和度</div>
                </div>
            </div>

            <div class="control-group">
                <h3>⚙️ 图像调整</h3>
                <div class="slider-group">
                    <label for="contrastSlider">对比度: <span id="contrastValue">1.0</span></label>
                    <input type="range" id="contrastSlider" class="slider" min="0.5" max="2.5" value="1" step="0.1">
                </div>
                <div class="slider-group">
                    <label for="saturationSlider">饱和度: <span id="saturationValue">1.0</span></label>
                    <input type="range" id="saturationSlider" class="slider" min="0.5" max="2" value="1" step="0.1">
                </div>
                <div class="slider-group">
                    <label for="sharpnessSlider">锐化: <span id="sharpnessValue">0</span></label>
                    <input type="range" id="sharpnessSlider" class="slider" min="0" max="3" value="0" step="0.1">
                </div>
                <div class="slider-group">
                    <label for="brightnessSlider">亮度: <span id="brightnessValue">0</span></label>
                    <input type="range" id="brightnessSlider" class="slider" min="-50" max="50" value="0" step="1">
                </div>
            </div>
        </div>

        <div class="palette-section">
            <h3>🎨 调色板数据库管理</h3>
            <div class="palette-controls">
                <div class="palette-selector">
                    <select id="paletteSelect">
                        <option value="default">默认31色调色板</option>
                    </select>
                    <button class="palette-btn" id="newPaletteBtn">新建调色板</button>
                    <button class="palette-btn" id="editPaletteBtn">编辑调色板</button>
                    <button class="palette-btn" id="deletePaletteBtn">删除调色板</button>
                </div>
                <button class="palette-btn" id="importPaletteBtn">导入调色板文件</button>
                <button class="palette-btn" id="exportPaletteBtn">导出当前调色板</button>
                <button class="palette-btn" id="addColorBtn">添加颜色</button>
                <input type="file" id="paletteFileInput" accept=".json,.txt,.pal" style="display: none;">
            </div>
            
            <div class="palette" id="palette"></div>
            
            <div class="color-editor" id="colorEditor">
                <h4>颜色编辑器</h4>
                <input type="text" id="colorName" placeholder="颜色名称">
                <input type="color" id="colorPicker">
                <input type="text" id="colorRGB" placeholder="RGB值 (r,g,b)">
                <div>
                    <button class="btn-save" id="saveColorBtn">保存</button>
                    <button class="btn-delete" id="deleteColorBtn">删除</button>
                    <button class="btn-cancel" id="cancelEditBtn">取消</button>
                </div>
            </div>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>正在使用高级算法转换中，请稍候...</p>
        </div>

        <div class="canvas-container">
            <div class="canvas-wrapper">
                <h3>📷 原始图片</h3>
                <canvas id="originalCanvas" width="400" height="400"></canvas>
            </div>
            <div class="canvas-wrapper">
                <h3>⚙️ 预处理结果</h3>
                <canvas id="processedCanvas" width="400" height="400"></canvas>
                <div class="preview-controls">
                    <button class="preview-btn active" data-canvas="processed" data-zoom="1">1x</button>
                    <button class="preview-btn" data-canvas="processed" data-zoom="2">2x</button>
                    <button class="preview-btn" data-canvas="processed" data-zoom="4">4x</button>
                </div>
            </div>
            <div class="canvas-wrapper">
                <h3>🖼️ 最终像素画</h3>
                <canvas id="pixelCanvas" width="400" height="400"></canvas>
                <div class="preview-controls">
                    <button class="preview-btn active" data-canvas="pixel" data-zoom="1">1x</button>
                    <button class="preview-btn" data-canvas="pixel" data-zoom="2">2x</button>
                    <button class="preview-btn" data-canvas="pixel" data-zoom="4">4x</button>
                </div>
            </div>
        </div>

        <div class="download-section" id="downloadSection" style="display: none;">
            <a href="#" id="downloadOriginalSize" class="download-btn">💾 下载原始尺寸</a>
            <a href="#" id="downloadLargeSize" class="download-btn">💾 下载高清版本</a>
            <a href="#" id="downloadPalette" class="download-btn">🎨 下载调色板</a>
        </div>

        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="originalSize">-</div>
                <div>原图尺寸</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="pixelSize">-</div>
                <div>像素画尺寸</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="usedColors">-</div>
                <div>使用颜色数</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="paletteColors">-</div>
                <div>调色板颜色数</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="processingTime">-</div>
                <div>处理时间</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="algorithm">-</div>
                <div>当前算法</div>
            </div>
        </div>
    </div>

    <script>
        // 调色板数据库管理类
        class PaletteDatabase {
            constructor() {
                this.palettes = new Map();
                this.currentPalette = 'default';
                this.loadDefaultPalette();
                this.loadFromStorage();
            }

            loadDefaultPalette() {
                const defaultColors = [
                    {name: 'Black', rgb: [0,0,0]},
                    {name: 'Dark Gray', rgb: [60,60,60]},
                    {name: 'Gray', rgb: [120,120,120]},
                    {name: 'Light Gray', rgb: [210,210,210]},
                    {name: 'White', rgb: [255,255,255]},
                    {name: 'Deep Red', rgb: [96,0,24]},
                    {name: 'Red', rgb: [237,28,36]},
                    {name: 'Orange', rgb: [255,127,39]},
                    {name: 'Gold', rgb: [246,170,9]},
                    {name: 'Yellow', rgb: [249,221,59]},
                    {name: 'Light Yellow', rgb: [255,250,188]},
                    {name: 'Dark Green', rgb: [14,185,104]},
                    {name: 'Green', rgb: [19,230,123]},
                    {name: 'Light Green', rgb: [135,255,94]},
                    {name: 'Dark Teal', rgb: [12,129,110]},
                    {name: 'Teal', rgb: [16,174,166]},
                    {name: 'Light Teal', rgb: [19,255,190]},
                    {name: 'Dark Blue', rgb: [40,80,158]},
                    {name: 'Blue', rgb: [64,147,228]},
                    {name: 'Cyan', rgb: [96,247,242]},
                    {name: 'Indigo', rgb: [107,80,246]},
                    {name: 'Light Indigo', rgb: [153,177,251]},
                    {name: 'Dark Purple', rgb: [120,12,153]},
                    {name: 'Purple', rgb: [170,56,185]},
                    {name: 'Light Purple', rgb: [224,159,249]},
                    {name: 'Dark Pink', rgb: [203,0,122]},
                    {name: 'Pink', rgb: [236,31,128]},
                    {name: 'Light Pink', rgb: [243,141,169]},
                    {name: 'Dark Brown', rgb: [104,70,52]},
                    {name: 'Brown', rgb: [149,104,42]},
                    {name: 'Beige', rgb: [248,178,119]}
                ];
                
                this.palettes.set('default', {
                    name: '默认31色调色板',
                    colors: defaultColors.map(color => ({...color, lab: this.rgbToLab(color.rgb)}))
                });
            }

            rgbToLab(rgb) {
                let [r, g, b] = rgb.map(x => x / 255);
                
                r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
                g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
                b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
                
                let x = (r * 0.4124 + g * 0.3576 + b * 0.1805) / 0.95047;
                let y = (r * 0.2126 + g * 0.7152 + b * 0.0722) / 1.00000;
                let z = (r * 0.0193 + g * 0.1192 + b * 0.9505) / 1.08883;
                
                x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + 16/116;
                y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + 16/116;
                z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + 16/116;
                
                return [
                    (116 * y) - 16,
                    500 * (x - y),
                    200 * (y - z)
                ];
            }

            saveToStorage() {
                const data = {};
                this.palettes.forEach((palette, key) => {
                    if (key !== 'default') {
                        data[key] = palette;
                    }
                });
                localStorage.setItem('pixelArtPalettes', JSON.stringify(data));
                localStorage.setItem('currentPalette', this.currentPalette);
            }

            loadFromStorage() {
                try {
                    const data = localStorage.getItem('pixelArtPalettes');
                    if (data) {
                        const palettes = JSON.parse(data);
                        Object.entries(palettes).forEach(([key, palette]) => {
                            this.palettes.set(key, palette);
                        });
                    }
                    
                    const currentPalette = localStorage.getItem('currentPalette');
                    if (currentPalette && this.palettes.has(currentPalette)) {
                        this.currentPalette = currentPalette;
                    }
                } catch (e) {
                    console.warn('无法加载调色板数据:', e);
                }
            }

            createPalette(name, colors = []) {
                const id = 'palette_' + Date.now();
                this.palettes.set(id, {
                    name: name,
                    colors: colors.map(color => ({...color, lab: this.rgbToLab(color.rgb)}))
                });
                this.saveToStorage();
                return id;
            }

            deletePalette(id) {
                if (id === 'default') return false;
                this.palettes.delete(id);
                if (this.currentPalette === id) {
                    this.currentPalette = 'default';
                }
                this.saveToStorage();
                return true;
            }

            getCurrentPalette() {
                return this.palettes.get(this.currentPalette);
            }

            getAllPalettes() {
                return Array.from(this.palettes.entries()).map(([id, palette]) => ({
                    id,
                    name: palette.name,
                    colorCount: palette.colors.length
                }));
            }

            addColorToPalette(paletteId, color) {
                const palette = this.palettes.get(paletteId);
                if (palette) {
                    palette.colors.push({...color, lab: this.rgbToLab(color.rgb)});
                    this.saveToStorage();
                }
            }

            removeColorFromPalette(paletteId, colorIndex) {
                const palette = this.palettes.get(paletteId);
                if (palette && colorIndex >= 0 && colorIndex < palette.colors.length) {
                    palette.colors.splice(colorIndex, 1);
                    this.saveToStorage();
                }
            }

            updateColorInPalette(paletteId, colorIndex, newColor) {
                const palette = this.palettes.get(paletteId);
                if (palette && colorIndex >= 0 && colorIndex < palette.colors.length) {
                    palette.colors[colorIndex] = {...newColor, lab: this.rgbToLab(newColor.rgb)};
                    this.saveToStorage();
                }
            }

            exportPalette(paletteId) {
                const palette = this.palettes.get(paletteId);
                if (!palette) return null;
                
                return {
                    name: palette.name,
                    colors: palette.colors.map(color => ({
                        name: color.name,
                        rgb: color.rgb
                    }))
                };
            }

            importPalette(name, paletteData) {
                const colors = paletteData.colors || paletteData;
                return this.createPalette(name, colors);
            }
        }

        // 全局变量
        let paletteDB = new PaletteDatabase();
        let currentSettings = {
            algorithm: 'euclidean',
            style: 'sharp',
            contrast: 1.0,
            saturation: 1.0,
            sharpness: 0,
            brightness: 0
        };

        let canvasStates = {
            processed: null,
            pixel: null
        };

        let zoomStates = {
            processed: 1,
            pixel: 1
        };

        let selectedColorIndex = -1;

        // 颜色距离算法
        const colorDistanceAlgorithms = {
            euclidean: (rgb1, rgb2) => {
                const dr = rgb1[0] - rgb2[0];
                const dg = rgb1[1] - rgb2[1];
                const db = rgb1[2] - rgb2[2];
                return Math.sqrt(dr * dr + dg * dg + db * db);
            },
            
            weighted: (rgb1, rgb2) => {
                const dr = rgb1[0] - rgb2[0];
                const dg = rgb1[1] - rgb2[1];
                const db = rgb1[2] - rgb2[2];
                const avgR = (rgb1[0] + rgb2[0]) / 2;
                const weightR = 2 + avgR / 256;
                const weightG = 4;
                const weightB = 2 + (255 - avgR) / 256;
                return Math.sqrt(weightR * dr * dr + weightG * dg * dg + weightB * db * db);
            },
            
            lab: (rgb1, rgb2) => {
                const lab1 = paletteDB.rgbToLab(rgb1);
                const lab2 = paletteDB.rgbToLab(rgb2);
                const dL = lab1[0] - lab2[0];
                const da = lab1[1] - lab2[1];
                const db = lab1[2] - lab2[2];
                return Math.sqrt(dL * dL + da * da + db * db);
            },

            adaptive: (rgb1, rgb2) => {
                // 自适应算法：根据亮度调整权重
                const brightness1 = (rgb1[0] * 0.299 + rgb1[1] * 0.587 + rgb1[2] * 0.114) / 255;
                const brightness2 = (rgb2[0] * 0.299 + rgb2[1] * 0.587 + rgb2[2] * 0.114) / 255;
                const brightnessDiff = Math.abs(brightness1 - brightness2);
                
                const dr = rgb1[0] - rgb2[0];
                const dg = rgb1[1] - rgb2[1];
                const db = rgb1[2] - rgb2[2];
                
                const colorDistance = Math.sqrt(dr * dr + dg * dg + db * db);
                return colorDistance * (1 + brightnessDiff);
            }
        };

        // 找到最接近的调色板颜色
        function findClosestColor(rgb, algorithm = 'euclidean') {
            const palette = paletteDB.getCurrentPalette();
            if (!palette || palette.colors.length === 0) return {rgb: [0, 0, 0], name: 'Black'};
            
            let closestColor = palette.colors[0];
            let minDistance = colorDistanceAlgorithms[algorithm](rgb, closestColor.rgb);

            for (let i = 1; i < palette.colors.length; i++) {
                const distance = colorDistanceAlgorithms[algorithm](rgb, palette.colors[i].rgb);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestColor = palette.colors[i];
                }
            }

            return closestColor;
        }

        // Floyd-Steinberg抖动算法
        function applyFloydSteinbergDithering(imageData, width, height) {
            const data = imageData.data;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const oldColor = [data[idx], data[idx + 1], data[idx + 2]];
                    const newColor = findClosestColor(oldColor, 'euclidean');
                    
                    data[idx] = newColor.rgb[0];
                    data[idx + 1] = newColor.rgb[1];
                    data[idx + 2] = newColor.rgb[2];
                    
                    const error = [
                        oldColor[0] - newColor.rgb[0],
                        oldColor[1] - newColor.rgb[1],
                        oldColor[2] - newColor.rgb[2]
                    ];
                    
                    // 分散误差到相邻像素
                    const errorDistribution = [
                        {x: 1, y: 0, factor: 7/16},
                        {x: -1, y: 1, factor: 3/16},
                        {x: 0, y: 1, factor: 5/16},
                        {x: 1, y: 1, factor: 1/16}
                    ];
                    
                    errorDistribution.forEach(({x: dx, y: dy, factor}) => {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            const nIdx = (ny * width + nx) * 4;
                            data[nIdx] = Math.max(0, Math.min(255, data[nIdx] + error[0] * factor));
                            data[nIdx + 1] = Math.max(0, Math.min(255, data[nIdx + 1] + error[1] * factor));
                            data[nIdx + 2] = Math.max(0, Math.min(255, data[nIdx + 2] + error[2] * factor));
                        }
                    });
                }
            }
            
            return imageData;
        }

        // 有序抖动算法
        function applyOrderedDithering(imageData, width, height) {
            const bayerMatrix = [
                [0, 8, 2, 10],
                [12, 4, 14, 6],
                [3, 11, 1, 9],
                [15, 7, 13, 5]
            ];
            
            const data = imageData.data;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const threshold = (bayerMatrix[y % 4][x % 4] + 1) / 17.0;
                    
                    const oldColor = [data[idx], data[idx + 1], data[idx + 2]];
                    
                    // 添加抖动噪声
                    const noisyColor = [
                        Math.max(0, Math.min(255, oldColor[0] + (Math.random() - 0.5) * threshold * 64)),
                        Math.max(0, Math.min(255, oldColor[1] + (Math.random() - 0.5) * threshold * 64)),
                        Math.max(0, Math.min(255, oldColor[2] + (Math.random() - 0.5) * threshold * 64))
                    ];
                    
                    const newColor = findClosestColor(noisyColor, 'euclidean');
                    
                    data[idx] = newColor.rgb[0];
                    data[idx + 1] = newColor.rgb[1];
                    data[idx + 2] = newColor.rgb[2];
                }
            }
            
            return imageData;
        }

        // 高级图像预处理
        function advancedPreprocessing(canvas, style, contrast, saturation, sharpness, brightness) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // 应用亮度、对比度和饱和度调整
            for (let i = 0; i < data.length; i += 4) {
                let r = data[i];
                let g = data[i + 1];
                let b = data[i + 2];

                // 亮度调整
                if (brightness !== 0) {
                    r = Math.max(0, Math.min(255, r + brightness));
                    g = Math.max(0, Math.min(255, g + brightness));
                    b = Math.max(0, Math.min(255, b + brightness));
                }

                // 对比度调整
                if (contrast !== 1) {
                    r = Math.max(0, Math.min(255, (r - 128) * contrast + 128));
                    g = Math.max(0, Math.min(255, (g - 128) * contrast + 128));
                    b = Math.max(0, Math.min(255, (b - 128) * contrast + 128));
                }

                // 饱和度调整
                if (saturation !== 1) {
                    const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                    r = Math.max(0, Math.min(255, gray + (r - gray) * saturation));
                    g = Math.max(0, Math.min(255, gray + (g - gray) * saturation));
                    b = Math.max(0, Math.min(255, gray + (b - gray) * saturation));
                }

                data[i] = r;
                data[i + 1] = g;
                data[i + 2] = b;
            }

            ctx.putImageData(imageData, 0, 0);

            // 根据风格应用不同的滤镜
            switch (style) {
                case 'soft':
                    ctx.filter = 'blur(0.5px)';
                    ctx.drawImage(canvas, 0, 0);
                    break;
                case 'retro':
                    ctx.filter = 'contrast(1.1) saturate(0.9) sepia(0.1)';
                    ctx.drawImage(canvas, 0, 0);
                    break;
                case 'artistic':
                    ctx.filter = 'contrast(1.2) saturate(1.3) hue-rotate(3deg)';
                    ctx.drawImage(canvas, 0, 0);
                    break;
                case 'minimal':
                    ctx.filter = 'contrast(0.9) saturate(0.7)';
                    ctx.drawImage(canvas, 0, 0);
                    break;
                case 'vibrant':
                    ctx.filter = 'contrast(1.3) saturate(1.5)';
                    ctx.drawImage(canvas, 0, 0);
                    break;
            }

            // 锐化处理
            if (sharpness > 0) {
                applySharpening(ctx, canvas.width, canvas.height, sharpness);
            }

            ctx.filter = 'none';
            return canvas;
        }

        // 锐化滤镜
        function applySharpening(ctx, width, height, amount) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const output = new ImageData(width, height);
            
            const kernel = [
                0, -amount, 0,
                -amount, 1 + 4 * amount, -amount,
                0, -amount, 0
            ];

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    for (let c = 0; c < 3; c++) {
                        let sum = 0;
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const idx = ((y + ky) * width + (x + kx)) * 4 + c;
                                sum += data[idx] * kernel[(ky + 1) * 3 + (kx + 1)];
                            }
                        }
                        const idx = (y * width + x) * 4 + c;
                        output.data[idx] = Math.max(0, Math.min(255, sum));
                    }
                    output.data[(y * width + x) * 4 + 3] = data[(y * width + x) * 4 + 3]; // Alpha
                }
            }
            
            ctx.putImageData(output, 0, 0);
        }

        // 转换为像素画的主函数
        async function convertToPixelArt(sourceCanvas, targetWidth, settings) {
            const startTime = Date.now();
            
            const aspectRatio = sourceCanvas.height / sourceCanvas.width;
            const targetHeight = Math.round(targetWidth * aspectRatio);

            // 创建预处理canvas
            const processedCanvas = document.createElement('canvas');
            const processedCtx = processedCanvas.getContext('2d');
            processedCanvas.width = sourceCanvas.width;
            processedCanvas.height = sourceCanvas.height;
            processedCtx.drawImage(sourceCanvas, 0, 0);

            // 应用高级预处理
            advancedPreprocessing(processedCanvas, settings.style, settings.contrast, settings.saturation, settings.sharpness, settings.brightness);

            // 保存预处理状态
            canvasStates.processed = {
                canvas: processedCanvas,
                width: processedCanvas.width,
                height: processedCanvas.height
            };

            // 显示预处理结果
            displayCanvasWithZoom('processedCanvas', processedCanvas, zoomStates.processed);

            // 创建缩放后的canvas
            const scaledCanvas = document.createElement('canvas');
            const scaledCtx = scaledCanvas.getContext('2d');
            scaledCanvas.width = targetWidth;
            scaledCanvas.height = targetHeight;
            
            scaledCtx.imageSmoothingEnabled = false;
            scaledCtx.drawImage(processedCanvas, 0, 0, targetWidth, targetHeight);

            // 应用颜色量化
            let imageData = scaledCtx.getImageData(0, 0, targetWidth, targetHeight);
            
            if (settings.algorithm === 'dithering') {
                imageData = applyFloydSteinbergDithering(imageData, targetWidth, targetHeight);
            } else if (settings.algorithm === 'ordered') {
                imageData = applyOrderedDithering(imageData, targetWidth, targetHeight);
            } else {
                const data = imageData.data;
                const usedColors = new Set();

                for (let i = 0; i < data.length; i += 4) {
                    const originalColor = [data[i], data[i + 1], data[i + 2]];
                    const closestColor = findClosestColor(originalColor, settings.algorithm);
                    
                    data[i] = closestColor.rgb[0];
                    data[i + 1] = closestColor.rgb[1];
                    data[i + 2] = closestColor.rgb[2];
                    
                    usedColors.add(closestColor.name);
                }

                // 更新使用颜色数统计
                document.getElementById('usedColors').textContent = usedColors.size;
            }

            scaledCtx.putImageData(imageData, 0, 0);

            // 保存像素画状态
            canvasStates.pixel = {
                canvas: scaledCanvas,
                width: scaledCanvas.width,
                height: scaledCanvas.height
            };

            // 显示像素画结果并恢复缩放状态
            displayCanvasWithZoom('pixelCanvas', scaledCanvas, zoomStates.pixel);

            // 更新统计信息
            const processingTime = Date.now() - startTime;
            const originalPixels = sourceCanvas.width * sourceCanvas.height;
            const pixelPixels = targetWidth * targetHeight;
            const compressionRatio = (originalPixels / pixelPixels).toFixed(1);
            const currentPalette = paletteDB.getCurrentPalette();

            document.getElementById('pixelSize').textContent = `${targetWidth}×${targetHeight}`;
            document.getElementById('processingTime').textContent = `${processingTime}ms`;
            document.getElementById('algorithm').textContent = getAlgorithmName(settings.algorithm);
            document.getElementById('paletteColors').textContent = currentPalette ? currentPalette.colors.length : 0;

            return scaledCanvas;
        }

        // 显示画布并支持缩放
        function displayCanvasWithZoom(canvasId, sourceCanvas, zoom) {
            const displayCanvas = document.getElementById(canvasId);
            const ctx = displayCanvas.getContext('2d');
            
            const maxSize = 400;
            let displayWidth, displayHeight;
            
            if (sourceCanvas.width > sourceCanvas.height) {
                displayWidth = Math.min(maxSize, sourceCanvas.width * zoom);
                displayHeight = displayWidth * (sourceCanvas.height / sourceCanvas.width);
            } else {
                displayHeight = Math.min(maxSize, sourceCanvas.height * zoom);
                displayWidth = displayHeight * (sourceCanvas.width / sourceCanvas.height);
            }
            
            displayCanvas.width = displayWidth;
            displayCanvas.height = displayHeight;
            
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(sourceCanvas, 0, 0, displayWidth, displayHeight);
        }

        // 获取算法显示名称
        function getAlgorithmName(algorithm) {
            const names = {
                'euclidean': '欧式',
                'weighted': '加权',
                'lab': 'LAB',
                'dithering': 'Floyd抖动',
                'ordered': '有序抖动',
                'adaptive': '自适应'
            };
            return names[algorithm] || algorithm;
        }

        // 更新调色板显示
        function updatePaletteDisplay() {
            const paletteEl = document.getElementById('palette');
            const currentPalette = paletteDB.getCurrentPalette();
            
            paletteEl.innerHTML = '';
            
            if (currentPalette && currentPalette.colors) {
                currentPalette.colors.forEach((color, index) => {
                    const swatch = document.createElement('div');
                    swatch.className = 'color-swatch';
                    swatch.style.backgroundColor = `rgb(${color.rgb[0]}, ${color.rgb[1]}, ${color.rgb[2]})`;
                    swatch.title = `${color.name}\nRGB(${color.rgb.join(', ')})`;
                    swatch.dataset.index = index;
                    
                    swatch.addEventListener('click', () => {
                        document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                        swatch.classList.add('selected');
                        selectedColorIndex = index;
                    });
                    
                    paletteEl.appendChild(swatch);
                });
            }
            
            // 更新统计
            document.getElementById('paletteColors').textContent = currentPalette ? currentPalette.colors.length : 0;
        }

        // 更新调色板选择器
        function updatePaletteSelector() {
            const selector = document.getElementById('paletteSelect');
            const palettes = paletteDB.getAllPalettes();
            
            selector.innerHTML = '';
            palettes.forEach(palette => {
                const option = document.createElement('option');
                option.value = palette.id;
                option.textContent = `${palette.name} (${palette.colorCount}色)`;
                if (palette.id === paletteDB.currentPalette) {
                    option.selected = true;
                }
                selector.appendChild(option);
            });
        }

        // 设置下载链接
        function setupDownloadLinks(pixelArtCanvas, width, height) {
            const downloadSection = document.getElementById('downloadSection');
            const downloadOriginal = document.getElementById('downloadOriginalSize');
            const downloadLarge = document.getElementById('downloadLargeSize');
            const downloadPalette = document.getElementById('downloadPalette');

            // 原始尺寸下载
            downloadOriginal.href = pixelArtCanvas.toDataURL('image/png');
            downloadOriginal.download = `pixel_art_${width}x${height}.png`;

            // 高清版本下载（放大4倍）
            const largeCanvas = document.createElement('canvas');
            const largeCtx = largeCanvas.getContext('2d');
            largeCanvas.width = pixelArtCanvas.width * 4;
            largeCanvas.height = pixelArtCanvas.height * 4;
            largeCtx.imageSmoothingEnabled = false;
            largeCtx.drawImage(pixelArtCanvas, 0, 0, largeCanvas.width, largeCanvas.height);
            
            downloadLarge.href = largeCanvas.toDataURL('image/png');
            downloadLarge.download = `pixel_art_${width}x${height}_4x.png`;

            // 调色板下载
            const paletteData = paletteDB.exportPalette(paletteDB.currentPalette);
            const paletteBlob = new Blob([JSON.stringify(paletteData, null, 2)], {type: 'application/json'});
            downloadPalette.href = URL.createObjectURL(paletteBlob);
            downloadPalette.download = `palette_${paletteData.name.replace(/\s+/g, '_')}.json`;

            downloadSection.style.display = 'flex';
        }

        // 恢复缩放按钮状态
        function restoreZoomButtonStates() {
            // 恢复预处理画布的缩放按钮状态
            const processedContainer = document.querySelector('[data-canvas="processed"]').closest('.canvas-wrapper');
            processedContainer.querySelectorAll('.preview-btn').forEach(btn => {
                btn.classList.remove('active');
                if (parseInt(btn.dataset.zoom) === zoomStates.processed) {
                    btn.classList.add('active');
                }
            });

            // 恢复像素画画布的缩放按钮状态
            const pixelContainer = document.querySelector('[data-canvas="pixel"]').closest('.canvas-wrapper');
            pixelContainer.querySelectorAll('.preview-btn').forEach(btn => {
                btn.classList.remove('active');
                if (parseInt(btn.dataset.zoom) === zoomStates.pixel) {
                    btn.classList.add('active');
                }
            });
        }

        // 主处理函数
        async function processSelectedImage() {
            const file = document.getElementById('imageInput').files[0];
            if (!file) return;

            const loading = document.getElementById('loading');
            loading.style.display = 'block';

            try {
                const img = new Image();
                img.onload = async function() {
                    // 显示原始图像
                    const originalCanvas = document.getElementById('originalCanvas');
                    const originalCtx = originalCanvas.getContext('2d');
                    
                    const maxDisplaySize = 400;
                    const displayAspectRatio = img.height / img.width;
                    let displayWidth, displayHeight;

                    if (img.width > img.height) {
                        displayWidth = Math.min(maxDisplaySize, img.width);
                        displayHeight = displayWidth * displayAspectRatio;
                    } else {
                        displayHeight = Math.min(maxDisplaySize, img.height);
                        displayWidth = displayHeight / displayAspectRatio;
                    }

                    originalCanvas.width = displayWidth;
                    originalCanvas.height = displayHeight;
                    originalCtx.drawImage(img, 0, 0, displayWidth, displayHeight);

                    // 更新原图尺寸信息
                    document.getElementById('originalSize').textContent = `${img.width}×${img.height}`;

                    // 获取当前设置
                    const targetWidth = parseInt(document.getElementById('widthSlider').value);
                    
                    // 转换为像素画
                    const pixelArtCanvas = await convertToPixelArt(originalCanvas, targetWidth, currentSettings);

                    // 恢复缩放按钮状态
                    restoreZoomButtonStates();

                    // 设置下载链接
                    setupDownloadLinks(pixelArtCanvas, targetWidth, Math.round(targetWidth * (img.height / img.width)));

                    loading.style.display = 'none';
                };

                img.src = URL.createObjectURL(file);
            } catch (error) {
                console.error('处理图像时出错:', error);
                loading.style.display = 'none';
                alert('处理图像时出错，请重试');
            }
        }

        // 事件监听器
        document.addEventListener('DOMContentLoaded', function() {
            updatePaletteDisplay();
            updatePaletteSelector();

            // 文件输入监听器
            document.getElementById('imageInput').addEventListener('change', processSelectedImage);

            // 调色板选择器
            document.getElementById('paletteSelect').addEventListener('change', function() {
                paletteDB.currentPalette = this.value;
                paletteDB.saveToStorage();
                updatePaletteDisplay();
                
                if (document.getElementById('imageInput').files[0]) {
                    processSelectedImage();
                }
            });

            // 算法选择器
            document.querySelectorAll('.algorithm-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('.algorithm-option').forEach(o => o.classList.remove('active'));
                    this.classList.add('active');
                    currentSettings.algorithm = this.dataset.algorithm;
                    
                    if (document.getElementById('imageInput').files[0]) {
                        processSelectedImage();
                    }
                });
            });

            // 风格选择器
            document.querySelectorAll('.style-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('.style-option').forEach(o => o.classList.remove('active'));
                    this.classList.add('active');
                    currentSettings.style = this.dataset.style;
                    
                    if (document.getElementById('imageInput').files[0]) {
                        processSelectedImage();
                    }
                });
            });

            // 滑块监听器
            const sliders = [
                {id: 'widthSlider', valueId: 'widthValue'},
                {id: 'contrastSlider', valueId: 'contrastValue', setting: 'contrast'},
                {id: 'saturationSlider', valueId: 'saturationValue', setting: 'saturation'},
                {id: 'sharpnessSlider', valueId: 'sharpnessValue', setting: 'sharpness'},
                {id: 'brightnessSlider', valueId: 'brightnessValue', setting: 'brightness'}
            ];

            sliders.forEach(({id, valueId, setting}) => {
                const slider = document.getElementById(id);
                const valueDisplay = document.getElementById(valueId);
                
                slider.addEventListener('input', function() {
                    valueDisplay.textContent = this.value;
                    if (setting) {
                        currentSettings[setting] = parseFloat(this.value);
                    }
                });

                slider.addEventListener('change', function() {
                    if (document.getElementById('imageInput').files[0]) {
                        processSelectedImage();
                    }
                });
            });

            // 预览缩放控制 - 修复版本，保存缩放状态
            document.querySelectorAll('.preview-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const canvasType = this.dataset.canvas;
                    const zoom = parseInt(this.dataset.zoom);
                    
                    // 保存缩放状态
                    zoomStates[canvasType] = zoom;
                    
                    // 更新按钮状态
                    const container = this.closest('.canvas-wrapper');
                    container.querySelectorAll('.preview-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    
                    // 重新显示对应的canvas
                    if (canvasType === 'processed' && canvasStates.processed) {
                        displayCanvasWithZoom('processedCanvas', canvasStates.processed.canvas, zoom);
                    } else if (canvasType === 'pixel' && canvasStates.pixel) {
                        displayCanvasWithZoom('pixelCanvas', canvasStates.pixel.canvas, zoom);
                    }
                });
            });

            // 调色板管理按钮
            document.getElementById('newPaletteBtn').addEventListener('click', function() {
                const name = prompt('请输入新调色板名称:');
                if (name) {
                    const id = paletteDB.createPalette(name, []);
                    paletteDB.currentPalette = id;
                    updatePaletteSelector();
                    updatePaletteDisplay();
                }
            });

            document.getElementById('editPaletteBtn').addEventListener('click', function() {
                if (paletteDB.currentPalette === 'default') {
                    alert('默认调色板不能编辑');
                    return;
                }
                const palette = paletteDB.getCurrentPalette();
                const newName = prompt('请输入新名称:', palette.name);
                if (newName && newName !== palette.name) {
                    palette.name = newName;
                    paletteDB.saveToStorage();
                    updatePaletteSelector();
                }
            });

            document.getElementById('deletePaletteBtn').addEventListener('click', function() {
                if (paletteDB.currentPalette === 'default') {
                    alert('默认调色板不能删除');
                    return;
                }
                if (confirm('确定要删除当前调色板吗？')) {
                    paletteDB.deletePalette(paletteDB.currentPalette);
                    paletteDB.currentPalette = 'default';
                    updatePaletteSelector();
                    updatePaletteDisplay();
                }
            });

            // 颜色管理
            document.getElementById('addColorBtn').addEventListener('click', function() {
                selectedColorIndex = -1;
                document.getElementById('colorName').value = '';
                document.getElementById('colorPicker').value = '#000000';
                document.getElementById('colorRGB').value = '';
                document.getElementById('colorEditor').classList.add('active');
            });

            document.getElementById('saveColorBtn').addEventListener('click', function() {
                const name = document.getElementById('colorName').value;
                const hex = document.getElementById('colorPicker').value;
                const rgbInput = document.getElementById('colorRGB').value;
                
                let rgb;
                if (rgbInput) {
                    const match = rgbInput.match(/(\d+),\s*(\d+),\s*(\d+)/);
                    if (match) {
                        rgb = [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])];
                    }
                }
                
                if (!rgb) {
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    rgb = [r, g, b];
                }
                
                if (name && rgb) {
                    const color = {name, rgb};
                    
                    if (selectedColorIndex >= 0) {
                        paletteDB.updateColorInPalette(paletteDB.currentPalette, selectedColorIndex, color);
                    } else {
                        paletteDB.addColorToPalette(paletteDB.currentPalette, color);
                    }
                    
                    updatePaletteDisplay();
                    document.getElementById('colorEditor').classList.remove('active');
                    
                    if (document.getElementById('imageInput').files[0]) {
                        processSelectedImage();
                    }
                }
            });

            document.getElementById('deleteColorBtn').addEventListener('click', function() {
                if (selectedColorIndex >= 0) {
                    paletteDB.removeColorFromPalette(paletteDB.currentPalette, selectedColorIndex);
                    updatePaletteDisplay();
                    document.getElementById('colorEditor').classList.remove('active');
                    
                    if (document.getElementById('imageInput').files[0]) {
                        processSelectedImage();
                    }
                }
            });

            document.getElementById('cancelEditBtn').addEventListener('click', function() {
                document.getElementById('colorEditor').classList.remove('active');
            });

            // 导入导出调色板
            document.getElementById('importPaletteBtn').addEventListener('click', function() {
                document.getElementById('paletteFileInput').click();
            });

            document.getElementById('paletteFileInput').addEventListener('change', function() {
                const file = this.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        let paletteData;
                        const content = e.target.result;
                        
                        if (file.name.endsWith('.json')) {
                            paletteData = JSON.parse(content);
                        } else if (file.name.endsWith('.txt') || file.name.endsWith('.pal')) {
                            // 支持简单的文本格式：每行一个颜色 "名称,r,g,b"
                            const lines = content.split('\n').filter(line => line.trim());
                            paletteData = {
                                name: file.name.replace(/\.[^/.]+$/, ""),
                                colors: lines.map(line => {
                                    const parts = line.split(',');
                                    if (parts.length >= 4) {
                                        return {
                                            name: parts[0].trim(),
                                            rgb: [parseInt(parts[1]), parseInt(parts[2]), parseInt(parts[3])]
                                        };
                                    }
                                }).filter(color => color && color.rgb.every(c => !isNaN(c)))
                            };
                        }
                        
                        if (paletteData && paletteData.colors && paletteData.colors.length > 0) {
                            const name = paletteData.name || file.name.replace(/\.[^/.]+$/, "");
                            const id = paletteDB.importPalette(name, paletteData);
                            paletteDB.currentPalette = id;
                            updatePaletteSelector();
                            updatePaletteDisplay();
                            alert(`成功导入调色板"${name}"，包含${paletteData.colors.length}种颜色`);
                        } else {
                            alert('调色板文件格式不正确');
                        }
                    } catch (error) {
                        alert('读取调色板文件失败: ' + error.message);
                    }
                };
                reader.readAsText(file);
            });

            document.getElementById('exportPaletteBtn').addEventListener('click', function() {
                const paletteData = paletteDB.exportPalette(paletteDB.currentPalette);
                if (paletteData) {
                    const blob = new Blob([JSON.stringify(paletteData, null, 2)], {type: 'application/json'});
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `palette_${paletteData.name.replace(/\s+/g, '_')}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }
            });

            // 文件选择按钮文字更新
            document.getElementById('imageInput').addEventListener('change', function() {
                const button = document.querySelector('.file-input-button');
                if (this.files[0]) {
                    button.textContent = `已选择: ${this.files[0].name}`;
                } else {
                    button.textContent = '选择图片文件';
                }
            });

            // 颜色编辑器中的颜色选择器更新RGB输入框
            document.getElementById('colorPicker').addEventListener('input', function() {
                const hex = this.value;
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                document.getElementById('colorRGB').value = `${r},${g},${b}`;
            });

            // RGB输入框更新颜色选择器
            document.getElementById('colorRGB').addEventListener('input', function() {
                const match = this.value.match(/(\d+),\s*(\d+),\s*(\d+)/);
                if (match) {
                    const r = Math.max(0, Math.min(255, parseInt(match[1])));
                    const g = Math.max(0, Math.min(255, parseInt(match[2])));
                    const b = Math.max(0, Math.min(255, parseInt(match[3])));
                    const hex = '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
                    document.getElementById('colorPicker').value = hex;
                }
            });

            // 双击颜色块编辑
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('color-swatch') && e.detail === 2) {
                    const index = parseInt(e.target.dataset.index);
                    const palette = paletteDB.getCurrentPalette();
                    if (palette && palette.colors[index]) {
                        const color = palette.colors[index];
                        selectedColorIndex = index;
                        document.getElementById('colorName').value = color.name;
                        document.getElementById('colorRGB').value = color.rgb.join(',');
                        const hex = '#' + color.rgb.map(x => x.toString(16).padStart(2, '0')).join('');
                        document.getElementById('colorPicker').value = hex;
                        document.getElementById('colorEditor').classList.add('active');
                    }
                }
            });
        });
    </script>
</body>
</html>