<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>åƒç´ ç”»è½¬æ¢å™¨v4</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 1800px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #333;
            font-size: 2.5em;
            margin-bottom: 10px;
            background: linear-gradient(45deg, #667eea, #764ba2);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
        }

        .main-controls {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .control-group {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #e9ecef;
        }

        .control-group h3 {
            color: #495057;
            margin-bottom: 15px;
            font-size: 1.1em;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            width: 100%;
            margin-bottom: 15px;
        }

        .file-input {
            position: absolute;
            opacity: 0;
            width: 100%;
            height: 100%;
            cursor: pointer;
        }

        .file-input-button {
            display: block;
            width: 100%;
            padding: 12px;
            background: linear-gradient(45deg, #28a745, #20c997);
            color: white;
            text-align: center;
            border-radius: 8px;
            border: none;
            font-size: 14px;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .file-input-button:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(40, 167, 69, 0.4);
        }

        .slider-group {
            margin-bottom: 12px;
        }

        .slider-group label {
            display: block;
            margin-bottom: 6px;
            color: #495057;
            font-weight: 500;
            font-size: 13px;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 18px;
            height: 18px;
            border-radius: 50%;
            background: #667eea;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0, 0, 0, 0.2);
        }

        .algorithm-selector, .style-selector {
            display: grid;
            gap: 8px;
            margin-bottom: 15px;
        }

        .algorithm-option, .style-option {
            padding: 10px;
            border: 2px solid #ddd;
            border-radius: 6px;
            cursor: pointer;
            text-align: center;
            transition: all 0.3s ease;
            background: white;
            font-size: 12px;
        }

        .algorithm-option:hover, .style-option:hover {
            border-color: #667eea;
        }

        .algorithm-option.active, .style-option.active {
            border-color: #667eea;
            background: #667eea;
            color: white;
            font-weight: bold;
        }

        .palette-section {
            background: #f8f9fa;
            padding: 20px;
            border-radius: 15px;
            border: 2px solid #e9ecef;
            margin-bottom: 20px;
        }

        .palette-controls {
            display: flex;
            gap: 10px;
            margin-bottom: 15px;
            flex-wrap: wrap;
        }

        .palette-btn {
            padding: 8px 16px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.3s ease;
        }

        .palette-btn:hover {
            background: #5a6fd8;
        }

        .palette-selector {
            margin-bottom: 15px;
        }

        .palette-selector select {
            width: 200px;
            padding: 8px;
            border: 2px solid #ddd;
            border-radius: 6px;
            margin-right: 10px;
        }

        .palette {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(30px, 1fr));
            gap: 3px;
            margin-bottom: 15px;
            padding: 15px;
            background: white;
            border-radius: 8px;
            max-height: 200px;
            overflow-y: auto;
        }

        .color-swatch {
            width: 30px;
            height: 30px;
            border-radius: 4px;
            border: 2px solid #ddd;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .color-swatch:hover {
            transform: scale(1.1);
            border-color: #333;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.2);
        }

        .color-swatch.selected {
            border-color: #ff0000;
            border-width: 3px;
        }

        .canvas-container {
            display: grid;
            grid-template-columns: 1fr 1fr 1fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        .canvas-wrapper {
            text-align: center;
            background: #f8f9fa;
            padding: 15px;
            border-radius: 15px;
            border: 2px solid #e9ecef;
        }

        .canvas-wrapper h3 {
            margin-bottom: 10px;
            color: #495057;
            font-size: 1em;
        }

        canvas {
            max-width: 100%;
            height: auto;
            border: 2px solid #ddd;
            border-radius: 8px;
            background: white;
        }

        .preview-controls {
            display: flex;
            justify-content: center;
            gap: 5px;
            margin: 10px 0;
        }

        .preview-btn {
            padding: 4px 8px;
            background: #6c757d;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 11px;
            transition: all 0.3s ease;
        }

        .preview-btn:hover {
            background: #495057;
        }

        .preview-btn.active {
            background: #667eea;
        }

        .download-section {
            display: flex;
            justify-content: center;
            gap: 15px;
            margin: 20px 0;
            flex-wrap: wrap;
        }

        .download-btn {
            padding: 10px 20px;
            background: linear-gradient(45deg, #dc3545, #fd7e14);
            color: white;
            text-decoration: none;
            border-radius: 8px;
            font-weight: bold;
            text-align: center;
            transition: all 0.3s ease;
            font-size: 12px;
        }

        .download-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(220, 53, 69, 0.4);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-top: 20px;
        }

        .stat-item {
            background: linear-gradient(45deg, #6c757d, #495057);
            color: white;
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .stat-value {
            font-size: 1.2em;
            font-weight: bold;
            margin-bottom: 3px;
        }

        .loading {
            display: none;
            text-align: center;
            margin: 20px 0;
        }

        .spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 40px;
            height: 40px;
            animation: spin 1s linear infinite;
            margin: 0 auto 10px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .color-editor {
            background: white;
            padding: 15px;
            border-radius: 8px;
            margin-top: 10px;
            border: 2px solid #ddd;
            display: none;
        }

        .color-editor.active {
            display: block;
        }

        .color-editor input {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
        }

        .color-editor button {
            padding: 8px 16px;
            margin: 5px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        .btn-save {
            background: #28a745;
            color: white;
        }

        .btn-delete {
            background: #dc3545;
            color: white;
        }

        .btn-cancel {
            background: #6c757d;
            color: white;
        }

        @media (max-width: 1400px) {
            .main-controls {
                grid-template-columns: 1fr 1fr;
            }
        }

        @media (max-width: 768px) {
            .main-controls {
                grid-template-columns: 1fr;
            }
            
            .canvas-container {
                grid-template-columns: 1fr;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¨ åƒç´ ç”»è½¬æ¢å™¨ v4</h1>
            <p>è¯·è¾“å…¥æ–‡å­—</p>
        </div>

        <div class="main-controls">
            <div class="control-group">
                <h3>ğŸ“ å›¾ç‰‡ä¸Šä¼ </h3>
                <div class="file-input-wrapper">
                    <input type="file" id="imageInput" class="file-input" accept="image/*">
                    <button class="file-input-button">é€‰æ‹©å›¾ç‰‡æ–‡ä»¶</button>
                </div>
                <div class="slider-group">
                    <label for="widthSlider">åƒç´ ç”»å®½åº¦: <span id="widthValue">64</span></label>
                    <input type="range" id="widthSlider" class="slider" min="16" max="256" value="64">
                </div>
            </div>

            <div class="control-group">
                <h3>ğŸ¯ è½¬æ¢ç®—æ³•</h3>
                <div class="algorithm-selector">
                    <div class="algorithm-option active" data-algorithm="euclidean">æ¬§å‡ é‡Œå¾—è·ç¦»</div>
                    <div class="algorithm-option" data-algorithm="weighted">åŠ æƒRGBè·ç¦»</div>
                    <div class="algorithm-option" data-algorithm="lab">LABè‰²å½©ç©ºé—´</div>
                    <div class="algorithm-option" data-algorithm="dithering">FloydæŠ–åŠ¨</div>
                    <div class="algorithm-option" data-algorithm="ordered">æœ‰åºæŠ–åŠ¨</div>
                    <div class="algorithm-option" data-algorithm="adaptive">è‡ªé€‚åº”é‡åŒ–</div>
                </div>
            </div>

            <div class="control-group">
                <h3>ğŸ¨ è‰ºæœ¯é£æ ¼</h3>
                <div class="style-selector">
                    <div class="style-option active" data-style="sharp">é”åˆ©æ¸…æ™°</div>
                    <div class="style-option" data-style="soft">æŸ”å’Œè‡ªç„¶</div>
                    <div class="style-option" data-style="retro">å¤å¤æ¸¸æˆ</div>
                    <div class="style-option" data-style="artistic">è‰ºæœ¯åŒ–</div>
                    <div class="style-option" data-style="minimal">æç®€ä¸»ä¹‰</div>
                    <div class="style-option" data-style="vibrant">é«˜é¥±å’Œåº¦</div>
                </div>
            </div>

            <div class="control-group">
                <h3>âš™ï¸ å›¾åƒè°ƒæ•´</h3>
                <div class="slider-group">
                    <label for="contrastSlider">å¯¹æ¯”åº¦: <span id="contrastValue">1.0</span></label>
                    <input type="range" id="contrastSlider" class="slider" min="0.5" max="2.5" value="1" step="0.1">
                </div>
                <div class="slider-group">
                    <label for="saturationSlider">é¥±å’Œåº¦: <span id="saturationValue">1.0</span></label>
                    <input type="range" id="saturationSlider" class="slider" min="0.5" max="2" value="1" step="0.1">
                </div>
                <div class="slider-group">
                    <label for="sharpnessSlider">é”åŒ–: <span id="sharpnessValue">0</span></label>
                    <input type="range" id="sharpnessSlider" class="slider" min="0" max="3" value="0" step="0.1">
                </div>
                <div class="slider-group">
                    <label for="brightnessSlider">äº®åº¦: <span id="brightnessValue">0</span></label>
                    <input type="range" id="brightnessSlider" class="slider" min="-50" max="50" value="0" step="1">
                </div>
            </div>
        </div>

        <div class="palette-section">
            <h3>ğŸ¨ è°ƒè‰²æ¿æ•°æ®åº“ç®¡ç†</h3>
            <div class="palette-controls">
                <div class="palette-selector">
                    <select id="paletteSelect">
                        <option value="default">é»˜è®¤31è‰²è°ƒè‰²æ¿</option>
                    </select>
                    <button class="palette-btn" id="newPaletteBtn">æ–°å»ºè°ƒè‰²æ¿</button>
                    <button class="palette-btn" id="editPaletteBtn">ç¼–è¾‘è°ƒè‰²æ¿</button>
                    <button class="palette-btn" id="deletePaletteBtn">åˆ é™¤è°ƒè‰²æ¿</button>
                </div>
                <button class="palette-btn" id="importPaletteBtn">å¯¼å…¥è°ƒè‰²æ¿æ–‡ä»¶</button>
                <button class="palette-btn" id="exportPaletteBtn">å¯¼å‡ºå½“å‰è°ƒè‰²æ¿</button>
                <button class="palette-btn" id="addColorBtn">æ·»åŠ é¢œè‰²</button>
                <input type="file" id="paletteFileInput" accept=".json,.txt,.pal" style="display: none;">
            </div>
            
            <div class="palette" id="palette"></div>
            
            <div class="color-editor" id="colorEditor">
                <h4>é¢œè‰²ç¼–è¾‘å™¨</h4>
                <input type="text" id="colorName" placeholder="é¢œè‰²åç§°">
                <input type="color" id="colorPicker">
                <input type="text" id="colorRGB" placeholder="RGBå€¼ (r,g,b)">
                <div>
                    <button class="btn-save" id="saveColorBtn">ä¿å­˜</button>
                    <button class="btn-delete" id="deleteColorBtn">åˆ é™¤</button>
                    <button class="btn-cancel" id="cancelEditBtn">å–æ¶ˆ</button>
                </div>
            </div>
        </div>

        <div class="loading" id="loading">
            <div class="spinner"></div>
            <p>æ­£åœ¨ä½¿ç”¨é«˜çº§ç®—æ³•è½¬æ¢ä¸­ï¼Œè¯·ç¨å€™...</p>
        </div>

        <div class="canvas-container">
            <div class="canvas-wrapper">
                <h3>ğŸ“· åŸå§‹å›¾ç‰‡</h3>
                <canvas id="originalCanvas" width="400" height="400"></canvas>
            </div>
            <div class="canvas-wrapper">
                <h3>âš™ï¸ é¢„å¤„ç†ç»“æœ</h3>
                <canvas id="processedCanvas" width="400" height="400"></canvas>
                <div class="preview-controls">
                    <button class="preview-btn active" data-canvas="processed" data-zoom="1">1x</button>
                    <button class="preview-btn" data-canvas="processed" data-zoom="2">2x</button>
                    <button class="preview-btn" data-canvas="processed" data-zoom="4">4x</button>
                </div>
            </div>
            <div class="canvas-wrapper">
                <h3>ğŸ–¼ï¸ æœ€ç»ˆåƒç´ ç”»</h3>
                <canvas id="pixelCanvas" width="400" height="400"></canvas>
                <div class="preview-controls">
                    <button class="preview-btn active" data-canvas="pixel" data-zoom="1">1x</button>
                    <button class="preview-btn" data-canvas="pixel" data-zoom="2">2x</button>
                    <button class="preview-btn" data-canvas="pixel" data-zoom="4">4x</button>
                </div>
            </div>
        </div>

        <div class="download-section" id="downloadSection" style="display: none;">
            <a href="#" id="downloadOriginalSize" class="download-btn">ğŸ’¾ ä¸‹è½½åŸå§‹å°ºå¯¸</a>
            <a href="#" id="downloadLargeSize" class="download-btn">ğŸ’¾ ä¸‹è½½é«˜æ¸…ç‰ˆæœ¬</a>
            <a href="#" id="downloadPalette" class="download-btn">ğŸ¨ ä¸‹è½½è°ƒè‰²æ¿</a>
        </div>

        <div class="stats">
            <div class="stat-item">
                <div class="stat-value" id="originalSize">-</div>
                <div>åŸå›¾å°ºå¯¸</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="pixelSize">-</div>
                <div>åƒç´ ç”»å°ºå¯¸</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="usedColors">-</div>
                <div>ä½¿ç”¨é¢œè‰²æ•°</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="paletteColors">-</div>
                <div>è°ƒè‰²æ¿é¢œè‰²æ•°</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="processingTime">-</div>
                <div>å¤„ç†æ—¶é—´</div>
            </div>
            <div class="stat-item">
                <div class="stat-value" id="algorithm">-</div>
                <div>å½“å‰ç®—æ³•</div>
            </div>
        </div>
    </div>

    <script>
        // è°ƒè‰²æ¿æ•°æ®åº“ç®¡ç†ç±»
        class PaletteDatabase {
            constructor() {
                this.palettes = new Map();
                this.currentPalette = 'default';
                this.loadDefaultPalette();
                this.loadFromStorage();
            }

            loadDefaultPalette() {
                const defaultColors = [
                    {name: 'Black', rgb: [0,0,0]},
                    {name: 'Dark Gray', rgb: [60,60,60]},
                    {name: 'Gray', rgb: [120,120,120]},
                    {name: 'Light Gray', rgb: [210,210,210]},
                    {name: 'White', rgb: [255,255,255]},
                    {name: 'Deep Red', rgb: [96,0,24]},
                    {name: 'Red', rgb: [237,28,36]},
                    {name: 'Orange', rgb: [255,127,39]},
                    {name: 'Gold', rgb: [246,170,9]},
                    {name: 'Yellow', rgb: [249,221,59]},
                    {name: 'Light Yellow', rgb: [255,250,188]},
                    {name: 'Dark Green', rgb: [14,185,104]},
                    {name: 'Green', rgb: [19,230,123]},
                    {name: 'Light Green', rgb: [135,255,94]},
                    {name: 'Dark Teal', rgb: [12,129,110]},
                    {name: 'Teal', rgb: [16,174,166]},
                    {name: 'Light Teal', rgb: [19,255,190]},
                    {name: 'Dark Blue', rgb: [40,80,158]},
                    {name: 'Blue', rgb: [64,147,228]},
                    {name: 'Cyan', rgb: [96,247,242]},
                    {name: 'Indigo', rgb: [107,80,246]},
                    {name: 'Light Indigo', rgb: [153,177,251]},
                    {name: 'Dark Purple', rgb: [120,12,153]},
                    {name: 'Purple', rgb: [170,56,185]},
                    {name: 'Light Purple', rgb: [224,159,249]},
                    {name: 'Dark Pink', rgb: [203,0,122]},
                    {name: 'Pink', rgb: [236,31,128]},
                    {name: 'Light Pink', rgb: [243,141,169]},
                    {name: 'Dark Brown', rgb: [104,70,52]},
                    {name: 'Brown', rgb: [149,104,42]},
                    {name: 'Beige', rgb: [248,178,119]}
                ];
                
                this.palettes.set('default', {
                    name: 'é»˜è®¤31è‰²è°ƒè‰²æ¿',
                    colors: defaultColors.map(color => ({...color, lab: this.rgbToLab(color.rgb)}))
                });
            }

            rgbToLab(rgb) {
                let [r, g, b] = rgb.map(x => x / 255);
                
                r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
                g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
                b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;
                
                let x = (r * 0.4124 + g * 0.3576 + b * 0.1805) / 0.95047;
                let y = (r * 0.2126 + g * 0.7152 + b * 0.0722) / 1.00000;
                let z = (r * 0.0193 + g * 0.1192 + b * 0.9505) / 1.08883;
                
                x = x > 0.008856 ? Math.pow(x, 1/3) : (7.787 * x) + 16/116;
                y = y > 0.008856 ? Math.pow(y, 1/3) : (7.787 * y) + 16/116;
                z = z > 0.008856 ? Math.pow(z, 1/3) : (7.787 * z) + 16/116;
                
                return [
                    (116 * y) - 16,
                    500 * (x - y),
                    200 * (y - z)
                ];
            }

            saveToStorage() {
                const data = {};
                this.palettes.forEach((palette, key) => {
                    if (key !== 'default') {
                        data[key] = palette;
                    }
                });
                localStorage.setItem('pixelArtPalettes', JSON.stringify(data));
                localStorage.setItem('currentPalette', this.currentPalette);
            }

            loadFromStorage() {
                try {
                    const data = localStorage.getItem('pixelArtPalettes');
                    if (data) {
                        const palettes = JSON.parse(data);
                        Object.entries(palettes).forEach(([key, palette]) => {
                            this.palettes.set(key, palette);
                        });
                    }
                    
                    const currentPalette = localStorage.getItem('currentPalette');
                    if (currentPalette && this.palettes.has(currentPalette)) {
                        this.currentPalette = currentPalette;
                    }
                } catch (e) {
                    console.warn('æ— æ³•åŠ è½½è°ƒè‰²æ¿æ•°æ®:', e);
                }
            }

            createPalette(name, colors = []) {
                const id = 'palette_' + Date.now();
                this.palettes.set(id, {
                    name: name,
                    colors: colors.map(color => ({...color, lab: this.rgbToLab(color.rgb)}))
                });
                this.saveToStorage();
                return id;
            }

            deletePalette(id) {
                if (id === 'default') return false;
                this.palettes.delete(id);
                if (this.currentPalette === id) {
                    this.currentPalette = 'default';
                }
                this.saveToStorage();
                return true;
            }

            getCurrentPalette() {
                return this.palettes.get(this.currentPalette);
            }

            getAllPalettes() {
                return Array.from(this.palettes.entries()).map(([id, palette]) => ({
                    id,
                    name: palette.name,
                    colorCount: palette.colors.length
                }));
            }

            addColorToPalette(paletteId, color) {
                const palette = this.palettes.get(paletteId);
                if (palette) {
                    palette.colors.push({...color, lab: this.rgbToLab(color.rgb)});
                    this.saveToStorage();
                }
            }

            removeColorFromPalette(paletteId, colorIndex) {
                const palette = this.palettes.get(paletteId);
                if (palette && colorIndex >= 0 && colorIndex < palette.colors.length) {
                    palette.colors.splice(colorIndex, 1);
                    this.saveToStorage();
                }
            }

            updateColorInPalette(paletteId, colorIndex, newColor) {
                const palette = this.palettes.get(paletteId);
                if (palette && colorIndex >= 0 && colorIndex < palette.colors.length) {
                    palette.colors[colorIndex] = {...newColor, lab: this.rgbToLab(newColor.rgb)};
                    this.saveToStorage();
                }
            }

            exportPalette(paletteId) {
                const palette = this.palettes.get(paletteId);
                if (!palette) return null;
                
                return {
                    name: palette.name,
                    colors: palette.colors.map(color => ({
                        name: color.name,
                        rgb: color.rgb
                    }))
                };
            }

            importPalette(name, paletteData) {
                const colors = paletteData.colors || paletteData;
                return this.createPalette(name, colors);
            }
        }

        // å…¨å±€å˜é‡
        let paletteDB = new PaletteDatabase();
        let currentSettings = {
            algorithm: 'euclidean',
            style: 'sharp',
            contrast: 1.0,
            saturation: 1.0,
            sharpness: 0,
            brightness: 0
        };

        let canvasStates = {
            processed: null,
            pixel: null
        };

        let zoomStates = {
            processed: 1,
            pixel: 1
        };

        let selectedColorIndex = -1;

        // é¢œè‰²è·ç¦»ç®—æ³•
        const colorDistanceAlgorithms = {
            euclidean: (rgb1, rgb2) => {
                const dr = rgb1[0] - rgb2[0];
                const dg = rgb1[1] - rgb2[1];
                const db = rgb1[2] - rgb2[2];
                return Math.sqrt(dr * dr + dg * dg + db * db);
            },
            
            weighted: (rgb1, rgb2) => {
                const dr = rgb1[0] - rgb2[0];
                const dg = rgb1[1] - rgb2[1];
                const db = rgb1[2] - rgb2[2];
                const avgR = (rgb1[0] + rgb2[0]) / 2;
                const weightR = 2 + avgR / 256;
                const weightG = 4;
                const weightB = 2 + (255 - avgR) / 256;
                return Math.sqrt(weightR * dr * dr + weightG * dg * dg + weightB * db * db);
            },
            
            lab: (rgb1, rgb2) => {
                const lab1 = paletteDB.rgbToLab(rgb1);
                const lab2 = paletteDB.rgbToLab(rgb2);
                const dL = lab1[0] - lab2[0];
                const da = lab1[1] - lab2[1];
                const db = lab1[2] - lab2[2];
                return Math.sqrt(dL * dL + da * da + db * db);
            },

            adaptive: (rgb1, rgb2) => {
                // è‡ªé€‚åº”ç®—æ³•ï¼šæ ¹æ®äº®åº¦è°ƒæ•´æƒé‡
                const brightness1 = (rgb1[0] * 0.299 + rgb1[1] * 0.587 + rgb1[2] * 0.114) / 255;
                const brightness2 = (rgb2[0] * 0.299 + rgb2[1] * 0.587 + rgb2[2] * 0.114) / 255;
                const brightnessDiff = Math.abs(brightness1 - brightness2);
                
                const dr = rgb1[0] - rgb2[0];
                const dg = rgb1[1] - rgb2[1];
                const db = rgb1[2] - rgb2[2];
                
                const colorDistance = Math.sqrt(dr * dr + dg * dg + db * db);
                return colorDistance * (1 + brightnessDiff);
            }
        };

        // æ‰¾åˆ°æœ€æ¥è¿‘çš„è°ƒè‰²æ¿é¢œè‰²
        function findClosestColor(rgb, algorithm = 'euclidean') {
            const palette = paletteDB.getCurrentPalette();
            if (!palette || palette.colors.length === 0) return {rgb: [0, 0, 0], name: 'Black'};
            
            let closestColor = palette.colors[0];
            let minDistance = colorDistanceAlgorithms[algorithm](rgb, closestColor.rgb);

            for (let i = 1; i < palette.colors.length; i++) {
                const distance = colorDistanceAlgorithms[algorithm](rgb, palette.colors[i].rgb);
                if (distance < minDistance) {
                    minDistance = distance;
                    closestColor = palette.colors[i];
                }
            }

            return closestColor;
        }

        // Floyd-SteinbergæŠ–åŠ¨ç®—æ³•
        function applyFloydSteinbergDithering(imageData, width, height) {
            const data = imageData.data;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const oldColor = [data[idx], data[idx + 1], data[idx + 2]];
                    const newColor = findClosestColor(oldColor, 'euclidean');
                    
                    data[idx] = newColor.rgb[0];
                    data[idx + 1] = newColor.rgb[1];
                    data[idx + 2] = newColor.rgb[2];
                    
                    const error = [
                        oldColor[0] - newColor.rgb[0],
                        oldColor[1] - newColor.rgb[1],
                        oldColor[2] - newColor.rgb[2]
                    ];
                    
                    // åˆ†æ•£è¯¯å·®åˆ°ç›¸é‚»åƒç´ 
                    const errorDistribution = [
                        {x: 1, y: 0, factor: 7/16},
                        {x: -1, y: 1, factor: 3/16},
                        {x: 0, y: 1, factor: 5/16},
                        {x: 1, y: 1, factor: 1/16}
                    ];
                    
                    errorDistribution.forEach(({x: dx, y: dy, factor}) => {
                        const nx = x + dx;
                        const ny = y + dy;
                        if (nx >= 0 && nx < width && ny >= 0 && ny < height) {
                            const nIdx = (ny * width + nx) * 4;
                            data[nIdx] = Math.max(0, Math.min(255, data[nIdx] + error[0] * factor));
                            data[nIdx + 1] = Math.max(0, Math.min(255, data[nIdx + 1] + error[1] * factor));
                            data[nIdx + 2] = Math.max(0, Math.min(255, data[nIdx + 2] + error[2] * factor));
                        }
                    });
                }
            }
            
            return imageData;
        }

        // æœ‰åºæŠ–åŠ¨ç®—æ³•
        function applyOrderedDithering(imageData, width, height) {
            const bayerMatrix = [
                [0, 8, 2, 10],
                [12, 4, 14, 6],
                [3, 11, 1, 9],
                [15, 7, 13, 5]
            ];
            
            const data = imageData.data;
            
            for (let y = 0; y < height; y++) {
                for (let x = 0; x < width; x++) {
                    const idx = (y * width + x) * 4;
                    const threshold = (bayerMatrix[y % 4][x % 4] + 1) / 17.0;
                    
                    const oldColor = [data[idx], data[idx + 1], data[idx + 2]];
                    
                    // æ·»åŠ æŠ–åŠ¨å™ªå£°
                    const noisyColor = [
                        Math.max(0, Math.min(255, oldColor[0] + (Math.random() - 0.5) * threshold * 64)),
                        Math.max(0, Math.min(255, oldColor[1] + (Math.random() - 0.5) * threshold * 64)),
                        Math.max(0, Math.min(255, oldColor[2] + (Math.random() - 0.5) * threshold * 64))
                    ];
                    
                    const newColor = findClosestColor(noisyColor, 'euclidean');
                    
                    data[idx] = newColor.rgb[0];
                    data[idx + 1] = newColor.rgb[1];
                    data[idx + 2] = newColor.rgb[2];
                }
            }
            
            return imageData;
        }

        // é«˜çº§å›¾åƒé¢„å¤„ç†
        function advancedPreprocessing(canvas, style, contrast, saturation, sharpness, brightness) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;

            // åº”ç”¨äº®åº¦ã€å¯¹æ¯”åº¦å’Œé¥±å’Œåº¦è°ƒæ•´
            for (let i = 0; i < data.length; i += 4) {
                let r = data[i];
                let g = data[i + 1];
                let b = data[i + 2];

                // äº®åº¦è°ƒæ•´
                if (brightness !== 0) {
                    r = Math.max(0, Math.min(255, r + brightness));
                    g = Math.max(0, Math.min(255, g + brightness));
                    b = Math.max(0, Math.min(255, b + brightness));
                }

                // å¯¹æ¯”åº¦è°ƒæ•´
                if (contrast !== 1) {
                    r = Math.max(0, Math.min(255, (r - 128) * contrast + 128));
                    g = Math.max(0, Math.min(255, (g - 128) * contrast + 128));
                    b = Math.max(0, Math.min(255, (b - 128) * contrast + 128));
                }

                // é¥±å’Œåº¦è°ƒæ•´
                if (saturation !== 1) {
                    const gray = 0.299 * r + 0.587 * g + 0.114 * b;
                    r = Math.max(0, Math.min(255, gray + (r - gray) * saturation));
                    g = Math.max(0, Math.min(255, gray + (g - gray) * saturation));
                    b = Math.max(0, Math.min(255, gray + (b - gray) * saturation));
                }

                data[i] = r;
                data[i + 1] = g;
                data[i + 2] = b;
            }

            ctx.putImageData(imageData, 0, 0);

            // æ ¹æ®é£æ ¼åº”ç”¨ä¸åŒçš„æ»¤é•œ
            switch (style) {
                case 'soft':
                    ctx.filter = 'blur(0.5px)';
                    ctx.drawImage(canvas, 0, 0);
                    break;
                case 'retro':
                    ctx.filter = 'contrast(1.1) saturate(0.9) sepia(0.1)';
                    ctx.drawImage(canvas, 0, 0);
                    break;
                case 'artistic':
                    ctx.filter = 'contrast(1.2) saturate(1.3) hue-rotate(3deg)';
                    ctx.drawImage(canvas, 0, 0);
                    break;
                case 'minimal':
                    ctx.filter = 'contrast(0.9) saturate(0.7)';
                    ctx.drawImage(canvas, 0, 0);
                    break;
                case 'vibrant':
                    ctx.filter = 'contrast(1.3) saturate(1.5)';
                    ctx.drawImage(canvas, 0, 0);
                    break;
            }

            // é”åŒ–å¤„ç†
            if (sharpness > 0) {
                applySharpening(ctx, canvas.width, canvas.height, sharpness);
            }

            ctx.filter = 'none';
            return canvas;
        }

        // é”åŒ–æ»¤é•œ
        function applySharpening(ctx, width, height, amount) {
            const imageData = ctx.getImageData(0, 0, width, height);
            const data = imageData.data;
            const output = new ImageData(width, height);
            
            const kernel = [
                0, -amount, 0,
                -amount, 1 + 4 * amount, -amount,
                0, -amount, 0
            ];

            for (let y = 1; y < height - 1; y++) {
                for (let x = 1; x < width - 1; x++) {
                    for (let c = 0; c < 3; c++) {
                        let sum = 0;
                        for (let ky = -1; ky <= 1; ky++) {
                            for (let kx = -1; kx <= 1; kx++) {
                                const idx = ((y + ky) * width + (x + kx)) * 4 + c;
                                sum += data[idx] * kernel[(ky + 1) * 3 + (kx + 1)];
                            }
                        }
                        const idx = (y * width + x) * 4 + c;
                        output.data[idx] = Math.max(0, Math.min(255, sum));
                    }
                    output.data[(y * width + x) * 4 + 3] = data[(y * width + x) * 4 + 3]; // Alpha
                }
            }
            
            ctx.putImageData(output, 0, 0);
        }

        // è½¬æ¢ä¸ºåƒç´ ç”»çš„ä¸»å‡½æ•°
        async function convertToPixelArt(sourceCanvas, targetWidth, settings) {
            const startTime = Date.now();
            
            const aspectRatio = sourceCanvas.height / sourceCanvas.width;
            const targetHeight = Math.round(targetWidth * aspectRatio);

            // åˆ›å»ºé¢„å¤„ç†canvas
            const processedCanvas = document.createElement('canvas');
            const processedCtx = processedCanvas.getContext('2d');
            processedCanvas.width = sourceCanvas.width;
            processedCanvas.height = sourceCanvas.height;
            processedCtx.drawImage(sourceCanvas, 0, 0);

            // åº”ç”¨é«˜çº§é¢„å¤„ç†
            advancedPreprocessing(processedCanvas, settings.style, settings.contrast, settings.saturation, settings.sharpness, settings.brightness);

            // ä¿å­˜é¢„å¤„ç†çŠ¶æ€
            canvasStates.processed = {
                canvas: processedCanvas,
                width: processedCanvas.width,
                height: processedCanvas.height
            };

            // æ˜¾ç¤ºé¢„å¤„ç†ç»“æœ
            displayCanvasWithZoom('processedCanvas', processedCanvas, zoomStates.processed);

            // åˆ›å»ºç¼©æ”¾åçš„canvas
            const scaledCanvas = document.createElement('canvas');
            const scaledCtx = scaledCanvas.getContext('2d');
            scaledCanvas.width = targetWidth;
            scaledCanvas.height = targetHeight;
            
            scaledCtx.imageSmoothingEnabled = false;
            scaledCtx.drawImage(processedCanvas, 0, 0, targetWidth, targetHeight);

            // åº”ç”¨é¢œè‰²é‡åŒ–
            let imageData = scaledCtx.getImageData(0, 0, targetWidth, targetHeight);
            
            if (settings.algorithm === 'dithering') {
                imageData = applyFloydSteinbergDithering(imageData, targetWidth, targetHeight);
            } else if (settings.algorithm === 'ordered') {
                imageData = applyOrderedDithering(imageData, targetWidth, targetHeight);
            } else {
                const data = imageData.data;
                const usedColors = new Set();

                for (let i = 0; i < data.length; i += 4) {
                    const originalColor = [data[i], data[i + 1], data[i + 2]];
                    const closestColor = findClosestColor(originalColor, settings.algorithm);
                    
                    data[i] = closestColor.rgb[0];
                    data[i + 1] = closestColor.rgb[1];
                    data[i + 2] = closestColor.rgb[2];
                    
                    usedColors.add(closestColor.name);
                }

                // æ›´æ–°ä½¿ç”¨é¢œè‰²æ•°ç»Ÿè®¡
                document.getElementById('usedColors').textContent = usedColors.size;
            }

            scaledCtx.putImageData(imageData, 0, 0);

            // ä¿å­˜åƒç´ ç”»çŠ¶æ€
            canvasStates.pixel = {
                canvas: scaledCanvas,
                width: scaledCanvas.width,
                height: scaledCanvas.height
            };

            // æ˜¾ç¤ºåƒç´ ç”»ç»“æœå¹¶æ¢å¤ç¼©æ”¾çŠ¶æ€
            displayCanvasWithZoom('pixelCanvas', scaledCanvas, zoomStates.pixel);

            // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
            const processingTime = Date.now() - startTime;
            const originalPixels = sourceCanvas.width * sourceCanvas.height;
            const pixelPixels = targetWidth * targetHeight;
            const compressionRatio = (originalPixels / pixelPixels).toFixed(1);
            const currentPalette = paletteDB.getCurrentPalette();

            document.getElementById('pixelSize').textContent = `${targetWidth}Ã—${targetHeight}`;
            document.getElementById('processingTime').textContent = `${processingTime}ms`;
            document.getElementById('algorithm').textContent = getAlgorithmName(settings.algorithm);
            document.getElementById('paletteColors').textContent = currentPalette ? currentPalette.colors.length : 0;

            return scaledCanvas;
        }

        // æ˜¾ç¤ºç”»å¸ƒå¹¶æ”¯æŒç¼©æ”¾
        function displayCanvasWithZoom(canvasId, sourceCanvas, zoom) {
            const displayCanvas = document.getElementById(canvasId);
            const ctx = displayCanvas.getContext('2d');
            
            const maxSize = 400;
            let displayWidth, displayHeight;
            
            if (sourceCanvas.width > sourceCanvas.height) {
                displayWidth = Math.min(maxSize, sourceCanvas.width * zoom);
                displayHeight = displayWidth * (sourceCanvas.height / sourceCanvas.width);
            } else {
                displayHeight = Math.min(maxSize, sourceCanvas.height * zoom);
                displayWidth = displayHeight * (sourceCanvas.width / sourceCanvas.height);
            }
            
            displayCanvas.width = displayWidth;
            displayCanvas.height = displayHeight;
            
            ctx.imageSmoothingEnabled = false;
            ctx.drawImage(sourceCanvas, 0, 0, displayWidth, displayHeight);
        }

        // è·å–ç®—æ³•æ˜¾ç¤ºåç§°
        function getAlgorithmName(algorithm) {
            const names = {
                'euclidean': 'æ¬§å¼',
                'weighted': 'åŠ æƒ',
                'lab': 'LAB',
                'dithering': 'FloydæŠ–åŠ¨',
                'ordered': 'æœ‰åºæŠ–åŠ¨',
                'adaptive': 'è‡ªé€‚åº”'
            };
            return names[algorithm] || algorithm;
        }

        // æ›´æ–°è°ƒè‰²æ¿æ˜¾ç¤º
        function updatePaletteDisplay() {
            const paletteEl = document.getElementById('palette');
            const currentPalette = paletteDB.getCurrentPalette();
            
            paletteEl.innerHTML = '';
            
            if (currentPalette && currentPalette.colors) {
                currentPalette.colors.forEach((color, index) => {
                    const swatch = document.createElement('div');
                    swatch.className = 'color-swatch';
                    swatch.style.backgroundColor = `rgb(${color.rgb[0]}, ${color.rgb[1]}, ${color.rgb[2]})`;
                    swatch.title = `${color.name}\nRGB(${color.rgb.join(', ')})`;
                    swatch.dataset.index = index;
                    
                    swatch.addEventListener('click', () => {
                        document.querySelectorAll('.color-swatch').forEach(s => s.classList.remove('selected'));
                        swatch.classList.add('selected');
                        selectedColorIndex = index;
                    });
                    
                    paletteEl.appendChild(swatch);
                });
            }
            
            // æ›´æ–°ç»Ÿè®¡
            document.getElementById('paletteColors').textContent = currentPalette ? currentPalette.colors.length : 0;
        }

        // æ›´æ–°è°ƒè‰²æ¿é€‰æ‹©å™¨
        function updatePaletteSelector() {
            const selector = document.getElementById('paletteSelect');
            const palettes = paletteDB.getAllPalettes();
            
            selector.innerHTML = '';
            palettes.forEach(palette => {
                const option = document.createElement('option');
                option.value = palette.id;
                option.textContent = `${palette.name} (${palette.colorCount}è‰²)`;
                if (palette.id === paletteDB.currentPalette) {
                    option.selected = true;
                }
                selector.appendChild(option);
            });
        }

        // è®¾ç½®ä¸‹è½½é“¾æ¥
        function setupDownloadLinks(pixelArtCanvas, width, height) {
            const downloadSection = document.getElementById('downloadSection');
            const downloadOriginal = document.getElementById('downloadOriginalSize');
            const downloadLarge = document.getElementById('downloadLargeSize');
            const downloadPalette = document.getElementById('downloadPalette');

            // åŸå§‹å°ºå¯¸ä¸‹è½½
            downloadOriginal.href = pixelArtCanvas.toDataURL('image/png');
            downloadOriginal.download = `pixel_art_${width}x${height}.png`;

            // é«˜æ¸…ç‰ˆæœ¬ä¸‹è½½ï¼ˆæ”¾å¤§4å€ï¼‰
            const largeCanvas = document.createElement('canvas');
            const largeCtx = largeCanvas.getContext('2d');
            largeCanvas.width = pixelArtCanvas.width * 4;
            largeCanvas.height = pixelArtCanvas.height * 4;
            largeCtx.imageSmoothingEnabled = false;
            largeCtx.drawImage(pixelArtCanvas, 0, 0, largeCanvas.width, largeCanvas.height);
            
            downloadLarge.href = largeCanvas.toDataURL('image/png');
            downloadLarge.download = `pixel_art_${width}x${height}_4x.png`;

            // è°ƒè‰²æ¿ä¸‹è½½
            const paletteData = paletteDB.exportPalette(paletteDB.currentPalette);
            const paletteBlob = new Blob([JSON.stringify(paletteData, null, 2)], {type: 'application/json'});
            downloadPalette.href = URL.createObjectURL(paletteBlob);
            downloadPalette.download = `palette_${paletteData.name.replace(/\s+/g, '_')}.json`;

            downloadSection.style.display = 'flex';
        }

        // æ¢å¤ç¼©æ”¾æŒ‰é’®çŠ¶æ€
        function restoreZoomButtonStates() {
            // æ¢å¤é¢„å¤„ç†ç”»å¸ƒçš„ç¼©æ”¾æŒ‰é’®çŠ¶æ€
            const processedContainer = document.querySelector('[data-canvas="processed"]').closest('.canvas-wrapper');
            processedContainer.querySelectorAll('.preview-btn').forEach(btn => {
                btn.classList.remove('active');
                if (parseInt(btn.dataset.zoom) === zoomStates.processed) {
                    btn.classList.add('active');
                }
            });

            // æ¢å¤åƒç´ ç”»ç”»å¸ƒçš„ç¼©æ”¾æŒ‰é’®çŠ¶æ€
            const pixelContainer = document.querySelector('[data-canvas="pixel"]').closest('.canvas-wrapper');
            pixelContainer.querySelectorAll('.preview-btn').forEach(btn => {
                btn.classList.remove('active');
                if (parseInt(btn.dataset.zoom) === zoomStates.pixel) {
                    btn.classList.add('active');
                }
            });
        }

        // ä¸»å¤„ç†å‡½æ•°
        async function processSelectedImage() {
            const file = document.getElementById('imageInput').files[0];
            if (!file) return;

            const loading = document.getElementById('loading');
            loading.style.display = 'block';

            try {
                const img = new Image();
                img.onload = async function() {
                    // æ˜¾ç¤ºåŸå§‹å›¾åƒ
                    const originalCanvas = document.getElementById('originalCanvas');
                    const originalCtx = originalCanvas.getContext('2d');
                    
                    const maxDisplaySize = 400;
                    const displayAspectRatio = img.height / img.width;
                    let displayWidth, displayHeight;

                    if (img.width > img.height) {
                        displayWidth = Math.min(maxDisplaySize, img.width);
                        displayHeight = displayWidth * displayAspectRatio;
                    } else {
                        displayHeight = Math.min(maxDisplaySize, img.height);
                        displayWidth = displayHeight / displayAspectRatio;
                    }

                    originalCanvas.width = displayWidth;
                    originalCanvas.height = displayHeight;
                    originalCtx.drawImage(img, 0, 0, displayWidth, displayHeight);

                    // æ›´æ–°åŸå›¾å°ºå¯¸ä¿¡æ¯
                    document.getElementById('originalSize').textContent = `${img.width}Ã—${img.height}`;

                    // è·å–å½“å‰è®¾ç½®
                    const targetWidth = parseInt(document.getElementById('widthSlider').value);
                    
                    // è½¬æ¢ä¸ºåƒç´ ç”»
                    const pixelArtCanvas = await convertToPixelArt(originalCanvas, targetWidth, currentSettings);

                    // æ¢å¤ç¼©æ”¾æŒ‰é’®çŠ¶æ€
                    restoreZoomButtonStates();

                    // è®¾ç½®ä¸‹è½½é“¾æ¥
                    setupDownloadLinks(pixelArtCanvas, targetWidth, Math.round(targetWidth * (img.height / img.width)));

                    loading.style.display = 'none';
                };

                img.src = URL.createObjectURL(file);
            } catch (error) {
                console.error('å¤„ç†å›¾åƒæ—¶å‡ºé”™:', error);
                loading.style.display = 'none';
                alert('å¤„ç†å›¾åƒæ—¶å‡ºé”™ï¼Œè¯·é‡è¯•');
            }
        }

        // äº‹ä»¶ç›‘å¬å™¨
        document.addEventListener('DOMContentLoaded', function() {
            updatePaletteDisplay();
            updatePaletteSelector();

            // æ–‡ä»¶è¾“å…¥ç›‘å¬å™¨
            document.getElementById('imageInput').addEventListener('change', processSelectedImage);

            // è°ƒè‰²æ¿é€‰æ‹©å™¨
            document.getElementById('paletteSelect').addEventListener('change', function() {
                paletteDB.currentPalette = this.value;
                paletteDB.saveToStorage();
                updatePaletteDisplay();
                
                if (document.getElementById('imageInput').files[0]) {
                    processSelectedImage();
                }
            });

            // ç®—æ³•é€‰æ‹©å™¨
            document.querySelectorAll('.algorithm-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('.algorithm-option').forEach(o => o.classList.remove('active'));
                    this.classList.add('active');
                    currentSettings.algorithm = this.dataset.algorithm;
                    
                    if (document.getElementById('imageInput').files[0]) {
                        processSelectedImage();
                    }
                });
            });

            // é£æ ¼é€‰æ‹©å™¨
            document.querySelectorAll('.style-option').forEach(option => {
                option.addEventListener('click', function() {
                    document.querySelectorAll('.style-option').forEach(o => o.classList.remove('active'));
                    this.classList.add('active');
                    currentSettings.style = this.dataset.style;
                    
                    if (document.getElementById('imageInput').files[0]) {
                        processSelectedImage();
                    }
                });
            });

            // æ»‘å—ç›‘å¬å™¨
            const sliders = [
                {id: 'widthSlider', valueId: 'widthValue'},
                {id: 'contrastSlider', valueId: 'contrastValue', setting: 'contrast'},
                {id: 'saturationSlider', valueId: 'saturationValue', setting: 'saturation'},
                {id: 'sharpnessSlider', valueId: 'sharpnessValue', setting: 'sharpness'},
                {id: 'brightnessSlider', valueId: 'brightnessValue', setting: 'brightness'}
            ];

            sliders.forEach(({id, valueId, setting}) => {
                const slider = document.getElementById(id);
                const valueDisplay = document.getElementById(valueId);
                
                slider.addEventListener('input', function() {
                    valueDisplay.textContent = this.value;
                    if (setting) {
                        currentSettings[setting] = parseFloat(this.value);
                    }
                });

                slider.addEventListener('change', function() {
                    if (document.getElementById('imageInput').files[0]) {
                        processSelectedImage();
                    }
                });
            });

            // é¢„è§ˆç¼©æ”¾æ§åˆ¶ - ä¿®å¤ç‰ˆæœ¬ï¼Œä¿å­˜ç¼©æ”¾çŠ¶æ€
            document.querySelectorAll('.preview-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    const canvasType = this.dataset.canvas;
                    const zoom = parseInt(this.dataset.zoom);
                    
                    // ä¿å­˜ç¼©æ”¾çŠ¶æ€
                    zoomStates[canvasType] = zoom;
                    
                    // æ›´æ–°æŒ‰é’®çŠ¶æ€
                    const container = this.closest('.canvas-wrapper');
                    container.querySelectorAll('.preview-btn').forEach(b => b.classList.remove('active'));
                    this.classList.add('active');
                    
                    // é‡æ–°æ˜¾ç¤ºå¯¹åº”çš„canvas
                    if (canvasType === 'processed' && canvasStates.processed) {
                        displayCanvasWithZoom('processedCanvas', canvasStates.processed.canvas, zoom);
                    } else if (canvasType === 'pixel' && canvasStates.pixel) {
                        displayCanvasWithZoom('pixelCanvas', canvasStates.pixel.canvas, zoom);
                    }
                });
            });

            // è°ƒè‰²æ¿ç®¡ç†æŒ‰é’®
            document.getElementById('newPaletteBtn').addEventListener('click', function() {
                const name = prompt('è¯·è¾“å…¥æ–°è°ƒè‰²æ¿åç§°:');
                if (name) {
                    const id = paletteDB.createPalette(name, []);
                    paletteDB.currentPalette = id;
                    updatePaletteSelector();
                    updatePaletteDisplay();
                }
            });

            document.getElementById('editPaletteBtn').addEventListener('click', function() {
                if (paletteDB.currentPalette === 'default') {
                    alert('é»˜è®¤è°ƒè‰²æ¿ä¸èƒ½ç¼–è¾‘');
                    return;
                }
                const palette = paletteDB.getCurrentPalette();
                const newName = prompt('è¯·è¾“å…¥æ–°åç§°:', palette.name);
                if (newName && newName !== palette.name) {
                    palette.name = newName;
                    paletteDB.saveToStorage();
                    updatePaletteSelector();
                }
            });

            document.getElementById('deletePaletteBtn').addEventListener('click', function() {
                if (paletteDB.currentPalette === 'default') {
                    alert('é»˜è®¤è°ƒè‰²æ¿ä¸èƒ½åˆ é™¤');
                    return;
                }
                if (confirm('ç¡®å®šè¦åˆ é™¤å½“å‰è°ƒè‰²æ¿å—ï¼Ÿ')) {
                    paletteDB.deletePalette(paletteDB.currentPalette);
                    paletteDB.currentPalette = 'default';
                    updatePaletteSelector();
                    updatePaletteDisplay();
                }
            });

            // é¢œè‰²ç®¡ç†
            document.getElementById('addColorBtn').addEventListener('click', function() {
                selectedColorIndex = -1;
                document.getElementById('colorName').value = '';
                document.getElementById('colorPicker').value = '#000000';
                document.getElementById('colorRGB').value = '';
                document.getElementById('colorEditor').classList.add('active');
            });

            document.getElementById('saveColorBtn').addEventListener('click', function() {
                const name = document.getElementById('colorName').value;
                const hex = document.getElementById('colorPicker').value;
                const rgbInput = document.getElementById('colorRGB').value;
                
                let rgb;
                if (rgbInput) {
                    const match = rgbInput.match(/(\d+),\s*(\d+),\s*(\d+)/);
                    if (match) {
                        rgb = [parseInt(match[1]), parseInt(match[2]), parseInt(match[3])];
                    }
                }
                
                if (!rgb) {
                    const r = parseInt(hex.slice(1, 3), 16);
                    const g = parseInt(hex.slice(3, 5), 16);
                    const b = parseInt(hex.slice(5, 7), 16);
                    rgb = [r, g, b];
                }
                
                if (name && rgb) {
                    const color = {name, rgb};
                    
                    if (selectedColorIndex >= 0) {
                        paletteDB.updateColorInPalette(paletteDB.currentPalette, selectedColorIndex, color);
                    } else {
                        paletteDB.addColorToPalette(paletteDB.currentPalette, color);
                    }
                    
                    updatePaletteDisplay();
                    document.getElementById('colorEditor').classList.remove('active');
                    
                    if (document.getElementById('imageInput').files[0]) {
                        processSelectedImage();
                    }
                }
            });

            document.getElementById('deleteColorBtn').addEventListener('click', function() {
                if (selectedColorIndex >= 0) {
                    paletteDB.removeColorFromPalette(paletteDB.currentPalette, selectedColorIndex);
                    updatePaletteDisplay();
                    document.getElementById('colorEditor').classList.remove('active');
                    
                    if (document.getElementById('imageInput').files[0]) {
                        processSelectedImage();
                    }
                }
            });

            document.getElementById('cancelEditBtn').addEventListener('click', function() {
                document.getElementById('colorEditor').classList.remove('active');
            });

            // å¯¼å…¥å¯¼å‡ºè°ƒè‰²æ¿
            document.getElementById('importPaletteBtn').addEventListener('click', function() {
                document.getElementById('paletteFileInput').click();
            });

            document.getElementById('paletteFileInput').addEventListener('change', function() {
                const file = this.files[0];
                if (!file) return;
                
                const reader = new FileReader();
                reader.onload = function(e) {
                    try {
                        let paletteData;
                        const content = e.target.result;
                        
                        if (file.name.endsWith('.json')) {
                            paletteData = JSON.parse(content);
                        } else if (file.name.endsWith('.txt') || file.name.endsWith('.pal')) {
                            // æ”¯æŒç®€å•çš„æ–‡æœ¬æ ¼å¼ï¼šæ¯è¡Œä¸€ä¸ªé¢œè‰² "åç§°,r,g,b"
                            const lines = content.split('\n').filter(line => line.trim());
                            paletteData = {
                                name: file.name.replace(/\.[^/.]+$/, ""),
                                colors: lines.map(line => {
                                    const parts = line.split(',');
                                    if (parts.length >= 4) {
                                        return {
                                            name: parts[0].trim(),
                                            rgb: [parseInt(parts[1]), parseInt(parts[2]), parseInt(parts[3])]
                                        };
                                    }
                                }).filter(color => color && color.rgb.every(c => !isNaN(c)))
                            };
                        }
                        
                        if (paletteData && paletteData.colors && paletteData.colors.length > 0) {
                            const name = paletteData.name || file.name.replace(/\.[^/.]+$/, "");
                            const id = paletteDB.importPalette(name, paletteData);
                            paletteDB.currentPalette = id;
                            updatePaletteSelector();
                            updatePaletteDisplay();
                            alert(`æˆåŠŸå¯¼å…¥è°ƒè‰²æ¿"${name}"ï¼ŒåŒ…å«${paletteData.colors.length}ç§é¢œè‰²`);
                        } else {
                            alert('è°ƒè‰²æ¿æ–‡ä»¶æ ¼å¼ä¸æ­£ç¡®');
                        }
                    } catch (error) {
                        alert('è¯»å–è°ƒè‰²æ¿æ–‡ä»¶å¤±è´¥: ' + error.message);
                    }
                };
                reader.readAsText(file);
            });

            document.getElementById('exportPaletteBtn').addEventListener('click', function() {
                const paletteData = paletteDB.exportPalette(paletteDB.currentPalette);
                if (paletteData) {
                    const blob = new Blob([JSON.stringify(paletteData, null, 2)], {type: 'application/json'});
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = `palette_${paletteData.name.replace(/\s+/g, '_')}.json`;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                }
            });

            // æ–‡ä»¶é€‰æ‹©æŒ‰é’®æ–‡å­—æ›´æ–°
            document.getElementById('imageInput').addEventListener('change', function() {
                const button = document.querySelector('.file-input-button');
                if (this.files[0]) {
                    button.textContent = `å·²é€‰æ‹©: ${this.files[0].name}`;
                } else {
                    button.textContent = 'é€‰æ‹©å›¾ç‰‡æ–‡ä»¶';
                }
            });

            // é¢œè‰²ç¼–è¾‘å™¨ä¸­çš„é¢œè‰²é€‰æ‹©å™¨æ›´æ–°RGBè¾“å…¥æ¡†
            document.getElementById('colorPicker').addEventListener('input', function() {
                const hex = this.value;
                const r = parseInt(hex.slice(1, 3), 16);
                const g = parseInt(hex.slice(3, 5), 16);
                const b = parseInt(hex.slice(5, 7), 16);
                document.getElementById('colorRGB').value = `${r},${g},${b}`;
            });

            // RGBè¾“å…¥æ¡†æ›´æ–°é¢œè‰²é€‰æ‹©å™¨
            document.getElementById('colorRGB').addEventListener('input', function() {
                const match = this.value.match(/(\d+),\s*(\d+),\s*(\d+)/);
                if (match) {
                    const r = Math.max(0, Math.min(255, parseInt(match[1])));
                    const g = Math.max(0, Math.min(255, parseInt(match[2])));
                    const b = Math.max(0, Math.min(255, parseInt(match[3])));
                    const hex = '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
                    document.getElementById('colorPicker').value = hex;
                }
            });

            // åŒå‡»é¢œè‰²å—ç¼–è¾‘
            document.addEventListener('click', function(e) {
                if (e.target.classList.contains('color-swatch') && e.detail === 2) {
                    const index = parseInt(e.target.dataset.index);
                    const palette = paletteDB.getCurrentPalette();
                    if (palette && palette.colors[index]) {
                        const color = palette.colors[index];
                        selectedColorIndex = index;
                        document.getElementById('colorName').value = color.name;
                        document.getElementById('colorRGB').value = color.rgb.join(',');
                        const hex = '#' + color.rgb.map(x => x.toString(16).padStart(2, '0')).join('');
                        document.getElementById('colorPicker').value = hex;
                        document.getElementById('colorEditor').classList.add('active');
                    }
                }
            });
        });
    </script>
</body>
</html>